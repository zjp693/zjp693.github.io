<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zjp693.github.io/</id>
    <title>学习笔记</title>
    <updated>2020-11-08T01:17:18.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zjp693.github.io/"/>
    <link rel="self" href="https://zjp693.github.io/atom.xml"/>
    <logo>https://zjp693.github.io/images/avatar.png</logo>
    <icon>https://zjp693.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 学习笔记</rights>
    <entry>
        <title type="html"><![CDATA[Vue基础_指令]]></title>
        <id>https://zjp693.github.io/post/vue-ji-chu-_-zhi-ling/</id>
        <link href="https://zjp693.github.io/post/vue-ji-chu-_-zhi-ling/">
        </link>
        <updated>2020-10-07T01:45:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="指令">指令</h2>
<h4 id="v-show-显示隐藏">v-show 显示隐藏</h4>
<ul>
<li>v-show指令的作用是：根据真假切换元素的显示状态</li>
<li>原理是修改元素的display,实现显示隐藏</li>
<li>指令后面的内容，最终都会解析为布尔值</li>
<li>数据改变之后，对应元素的显示状态会同步更新</li>
</ul>
<h4 id="v-if-条件判断">v-if  条件判断</h4>
<ul>
<li>v-if指令的作用是：根据表达式的真假切换元素的显示状态</li>
<li>本质是通过操纵dom元素来切换显示状态</li>
<li>表达式的值为true,元素存在dom树中，为false,从dom树中移除</li>
<li>频繁的切换v-show ,反之使用v-if,前者的切换消耗小</li>
</ul>
<h4 id="v-bind-属性绑定">v-bind 属性绑定</h4>
<ul>
<li>v-bind指令的作用是：为元素绑定属性</li>
<li>完整的写法是v-bind属性名</li>
<li>简写的话可以直接省略v-bind,只保留属性名</li>
<li>需要动态的增删class建议使用对象的方式</li>
</ul>
<h4 id="v-for-循环">v-for 循环</h4>
<ul>
<li>v-for指令的作用是：根据数据生成列表结构</li>
<li>数组经常和v-for结合使用</li>
<li>语法是（item,index) in 数据</li>
<li>item和index可以结合其他指令一起使用</li>
<li>数组长度的更新会同步到页面，是响应式</li>
</ul>
<h4 id="v-on-绑定事件">v-on  绑定事件</h4>
<ul>
<li>事件绑定的方法写成函数调用的形式，可以传入自定义参数</li>
<li>定义方法时需要形参来接收传入的实参</li>
<li>事件的后面跟上.修饰符可以对事件进行限制</li>
<li>.enter可以限制触发的按键为回车</li>
<li>事件修饰符有多种</li>
</ul>
<h4 id="v-model-双向数据绑定">v-model  双向数据绑定</h4>
<ul>
<li>v-model指令的作用是便携的设置和获取表单元素的值</li>
<li>绑定的元素会和表单元素值相关联</li>
<li>绑定数据  ==  表单元素的值</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VScode常见的代码用户片段]]></title>
        <id>https://zjp693.github.io/post/vscode-chang-jian-de-dai-ma-yong-hu-pian-duan/</id>
        <link href="https://zjp693.github.io/post/vscode-chang-jian-de-dai-ma-yong-hu-pian-duan/">
        </link>
        <updated>2020-05-16T09:54:58.000Z</updated>
        <content type="html"><![CDATA[<p>下面的代码片段是js中常用的一些代码结构，复制粘贴到对应的javascript.json文件中即可</p>
<pre><code class="language-json{">	// Place your snippets for JavaScript here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	&quot;Print to console&quot;: {
		&quot;prefix&quot;: &quot;log&quot;,
		&quot;body&quot;: [
			&quot;console.log('$1');&quot;,
		],
		&quot;description&quot;: &quot;Log output to console&quot;
	},
	&quot;zhe shi ajax kuai jie jian&quot;: {
		&quot;prefix&quot;: &quot;get&quot;,
		&quot;body&quot;: [
			&quot;//(1)创建小黄人对象&quot;,
			&quot;var xhr = new XMLHttpRequest();&quot;,
			&quot;//(2)设置请求方法与地址&quot;,
			&quot;xhr.open('get','https://autumnfish.cn/api/hero/simple?name=凯特琳')&quot;,
			&quot;//(3)发送请求&quot;,
			&quot;xhr.send();&quot;,
			&quot;//(4)注册响应回调&quot;,
			&quot;xhr.onload = function(){&quot;,
			&quot;\tconsole.log(xhr.responseText);&quot;,
			&quot;};&quot;,
		],
		&quot;description&quot;: &quot;这是ajax快捷键&quot;
	},
	&quot;yulan tupian&quot;: {
		&quot;prefix&quot;: &quot;ajax_yulan&quot;,
		&quot;body&quot;: [
			&quot;//1.给file表单元素注册onchange事件&quot;,
			&quot;$('file表单').change(function () {&quot;,
			&quot;\t//1.2 获取用户选择的图片&quot;,
			&quot;\tvar file = this.files[0];&quot;,
			&quot;\t//1.3 将文件转为src路径&quot;,
			&quot;\tvar url = URL.createObjectURL(file);&quot;,
			&quot;\t//1.4 将url路径赋值给img标签的src&quot;,
			&quot;\t$('img元素').attr('src', url);&quot;,
			&quot;});&quot;
		],
		&quot;description&quot;: &quot;图片预览固定四个步骤&quot;
	},
	&quot;comment for function&quot;: {
		&quot;prefix&quot;: &quot;///&quot;,
		&quot;body&quot;: [
			&quot;/**&quot;,
			&quot;* @description:&quot;,
			&quot;* @param {type} &quot;,
			&quot;* @return: &quot;,
			&quot;*/&quot;,
		],
		&quot;description&quot;: &quot;函数标准注释快捷键&quot;
	},
	&quot;jquery to ajax&quot;: {
		&quot;prefix&quot;: &quot;ajax&quot;,
		&quot;body&quot;: [
			&quot;$.ajax({&quot;,
			&quot;\turl:'',&quot;,
			&quot;\ttype:'get',&quot;,
			&quot;\tdataType:'json',&quot;,
			&quot;\tdata:'',&quot;,
			&quot;\tsuccess: function(backData){&quot;,
			&quot;&quot;,
			&quot;\t}&quot;,
			&quot;});&quot;
		],
		&quot;description&quot;: &quot;ajax请求&quot;
	},
	&quot;get for XMLHTTPRequest&quot;: {
		&quot;prefix&quot;: &quot;ajax1&quot;,
		&quot;body&quot;: [
			&quot;//(1).实例化ajax对象&quot;,
			&quot;var xhr = new XMLHttpRequest();&quot;,
			&quot;//(2).设置请求方法和地址&quot;,
			&quot;//get请求的数据直接添加在url的后面 格式是 url?key=value&quot;,
			&quot;xhr.open('get', '接口url');&quot;,
			&quot;//(3).发送请求&quot;,
			&quot;xhr.send();&quot;,
			&quot;//(4).注册回调函数&quot;,
			&quot;xhr.onload = function() {&quot;,
			&quot;\tconsole.log(xhr.responseText)&quot;,
			&quot;};&quot;,
		],
		&quot;description&quot;: &quot;get-原生XMLHTTPRequest实现ajax&quot;
	},
	&quot;post for XMLHTTPRequest&quot;: {
		&quot;prefix&quot;: &quot;ajax2&quot;,
		&quot;body&quot;: [
			&quot;//(1).实例化ajax对象&quot;,
			&quot;var xhr = new XMLHttpRequest();&quot;,
			&quot;//(2).设置请求方法和地址&quot;,
			&quot;xhr.open('post', '接口url');&quot;,
			&quot;//(3).设置请求头（post请求才需要设置）&quot;,
			&quot;xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded');&quot;,
			&quot;//(4).发送请求 ： 参数格式  'key=value' &quot;,
			&quot;xhr.send('key=value');&quot;,
			&quot;//(5).注册回调函数&quot;,
			&quot;xhr.onload = function () {&quot;,
			&quot;\tconsole.log(xhr.responseText);&quot;,
			&quot;};&quot;
		],
		&quot;description&quot;: &quot;post-原生XMLHTTPRequest实现ajax&quot;
	},
	&quot;file to ajax&quot;: {
		&quot;prefix&quot;: &quot;ajax-file&quot;,
		&quot;body&quot;: [
			&quot;$('提交按钮').on('click',function(e){&quot;,
			&quot;\t//禁用表单默认提交事件&quot;,
			&quot;\te.preventDefault();&quot;,
			&quot;\t//创建FormData对象：参数是表单dom对象&quot;,
			&quot;\tvar fd = new FormData('form表单DOM对象')&quot;,
			&quot;\t$.ajax({&quot;,
			&quot;\t\turl:'',&quot;,
			&quot;\t\ttype:'post',&quot;,
			&quot;\t\tdataType:'json',&quot;,
			&quot;\t\tdata:fd,&quot;,
			&quot;\t\tcontentType: false,&quot;,
			&quot;\t\tprocessData: false,&quot;,
			&quot;\t\tsuccess: function(backData){&quot;,
			&quot;\t\t}&quot;,
			&quot;\t});&quot;,
			&quot;});&quot;
		],
		&quot;description&quot;: &quot;表单提交ajax请求&quot;
	},
	&quot;express-server&quot;: {
		&quot;prefix&quot;: &quot;express&quot;,
		&quot;body&quot;: [
			&quot;//1.导入模块&quot;,
			&quot;const express = require('express');&quot;,
			&quot;//2.创建服务器&quot;,
			&quot;let app = express();&quot;,
			&quot;//3.开启服务器&quot;,
			&quot;app.listen(3000,()=&gt;{&quot;,
			&quot;console.log('success');&quot;,
			&quot;});&quot;
		],
		&quot;description&quot;: &quot;快速搭建express服务器&quot;
	},
	&quot;get element by id&quot;: {
		&quot;prefix&quot;: &quot;gid&quot;,
		&quot;body&quot;: [
			&quot;var box = document.getElementById('box')&quot;,
		],
		&quot;description&quot;: &quot;根据id获取元素&quot;
	},
	&quot;enmu arr&quot;: {
		&quot;prefix&quot;: &quot;forin&quot;,
		&quot;body&quot;: [
			&quot;for(var i = 0;i&lt;arr.length;i++){&quot;,
			&quot;console.log(arr[i]);&quot;,
			&quot;}&quot;,
		],
		&quot;description&quot;: &quot;数组快速for循环遍历&quot;
	},
	&quot;get elment by tagname&quot;: {
		&quot;prefix&quot;: &quot;gtg&quot;,
		&quot;body&quot;: [
			&quot;var liList = document.getElementsByTagName('li')&quot;,
		],
		&quot;description&quot;: &quot;根据标签名获取元素&quot;
	},
	&quot;get elment by classname&quot;: {
		&quot;prefix&quot;: &quot;gcn&quot;,
		&quot;body&quot;: [
			&quot;var oneList = document.getElementsByClassName('one')&quot;,
		],
		&quot;description&quot;: &quot;根据类名获取元素&quot;
	},
	&quot;quick event&quot;: {
		&quot;prefix&quot;: &quot;click&quot;,
		&quot;body&quot;: [
			&quot;//注册事件&quot;,
			&quot;box.onclick = function(){}&quot;,
		],
		&quot;description&quot;: &quot;快速注册点击事件&quot;
	},
	&quot;需求分析&quot;: {
		&quot;prefix&quot;: &quot;silu1&quot;,
		&quot;body&quot;: [
			&quot;/*&quot;,
			&quot;1.分析需求(交互)：&quot;,
			&quot;2.思路分析（事件三要素）&quot;,
			&quot;\t获取元素：事件源：&quot;,
			&quot;\t注册事件：事件类型&quot;,
			&quot;\t事件处理：&quot;,
			&quot;*/&quot;,
		],
		&quot;description&quot;: &quot;分析需求&quot;
	},
	&quot;根据思路实现需求&quot;: {
		&quot;prefix&quot;: &quot;silu2&quot;,
		&quot;body&quot;: [
			&quot;//1.获取元素&quot;,
			&quot;var box = document.getElementById('box');&quot;,
			&quot;//2.注册事件&quot;,
			&quot;box.onclick = function () {&quot;,
			&quot;\t//3.事件处理:&quot;,
			&quot;};&quot;,
		],
		&quot;description&quot;: &quot;根据思路实现需求&quot;
	},
	&quot;遍历对象&quot;: {
		&quot;prefix&quot;: &quot;forin1&quot;,
		&quot;body&quot;: [
			&quot;for(var key in obj){&quot;,
			&quot;\tvar value = obj[key]&quot;,
			&quot;}&quot;,
		],
		&quot;description&quot;: &quot;遍历对象快捷语法&quot;
	},
	&quot;axios&quot;: {
		&quot;prefix&quot;: &quot;axios&quot;,
		&quot;body&quot;: [
			&quot;axios({&quot;,
				&quot;\turl:'请求路径',&quot;,
				&quot;\tmethod:'get',&quot;,
				&quot;\tdata: { 'post请求参数'},&quot;,
				&quot;\tparams: { 'get请求参数'}&quot;,
			&quot;}).then(res=&gt;{&quot;,
				&quot;\t//成功回调&quot;,
				&quot;\tconsole.log(res)&quot;,
			&quot;});&quot;,
		],
		&quot;description&quot;: &quot;axios请求&quot;
	},
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web APIs笔记]]></title>
        <id>https://zjp693.github.io/post/web-apis-bi-ji/</id>
        <link href="https://zjp693.github.io/post/web-apis-bi-ji/">
        </link>
        <updated>2020-04-01T02:40:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="day01-web-apis">day01 - Web APIs</h1>
<blockquote>
<p>学习目标：</p>
<p>能够通过ID来获取元素<br>
能够通过标签名来获取元素<br>
能够通过class来获取元素<br>
能够通过选择器来获取元素<br>
能够获取body和html元素<br>
能够给元素注册事件<br>
能够修改元素的内容<br>
能够区分innerText和innerHTML的区别<br>
能够修改像div这类普通元素的属性<br>
能够修改表单元素的属性<br>
能够修改元素的样式属性</p>
</blockquote>
<h2 id="11-web-api介绍">1.1. Web API介绍</h2>
<h3 id="111-api的概念">1.1.1 API的概念</h3>
<p>API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</p>
<p><a href="images/1550719355829.png">1550719355829</a></p>
<blockquote>
<p>举例解释什么是API。</p>
<p>例如，</p>
<p>​	C语言中有一个函数 fopen()可以打开硬盘上的文件，这个函数对于我们来说，就是一个C语言提供的打开文件的工具。</p>
<p>​	javascript中有一个函数alert()可以在页面弹一个提示框，这个函数就是js提供的一个弹框工具。</p>
<p>这些工具（函数）由编程语言提供，内部的实现已经封装好了，我们只要学会灵活的使用这些工具即可。</p>
</blockquote>
<h3 id="112-web-api的概念">1.1.2 Web  API的概念</h3>
<p>​	Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p>
<p>​	现阶段我们主要针对于浏览器讲解常用的 API , 主要针对浏览器做交互效果。比如我们想要浏览器弹出一个警示框， 直接使用 alert(‘弹出’)</p>
<p>​	MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API</p>
<p>​	因为 Web API 很多，所以我们将这个阶段称为 Web APIs。</p>
<p>​	此处的 Web API 特指浏览器提供的一系列API(很多函数或对象方法)，即操作网页的一系列工具。例如：操作html标签、操作页面地址的方法。</p>
<h3 id="113-api-和-web-api-总结">1.1.3 API 和 Web  API 总结</h3>
<ol>
<li>
<p>API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现</p>
</li>
<li>
<p>Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。</p>
</li>
<li>
<p>Web API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法（函数）</p>
</li>
<li>
<p>学习 Web API 可以结合前面学习内置对象方法的思路学习</p>
</li>
</ol>
<h2 id="12-dom-介绍">1.2. DOM 介绍</h2>
<h3 id="121-什么是dom">1.2.1 什么是DOM</h3>
<p>​	文档对象模型（Document Object Model，简称DOM），是 <a href="https://baike.baidu.com/item/W3C">W3C</a> 组织推荐的处理<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">可扩展标记语言</a>（html或者xhtml）的标准<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3">编程接口</a>。</p>
<p>​	W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p>
<blockquote>
<p>DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。</p>
</blockquote>
<h3 id="122-dom树">1.2.2. DOM树</h3>
<figure data-type="image" tabindex="1"><img src="images/1550731974575.png" alt="1550731974575" loading="lazy"></figure>
<p>DOM树 又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。</p>
<ul>
<li>文档：一个页面就是一个文档，DOM中使用document表示</li>
<li>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</li>
<li>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</li>
</ul>
<figure data-type="image" tabindex="2"><img src="images/1550732362134.png" alt="1550732362134" loading="lazy"></figure>
<h2 id="13-获取元素">1.3. 获取元素</h2>
<p>为什么要获取页面元素？</p>
<p>例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。</p>
<h3 id="131-根据id获取">1.3.1. 根据ID获取</h3>
<pre><code class="language-js">语法：document.getElementById(id)
作用：根据ID获取元素对象
参数：id值，区分大小写的字符串
返回值：元素对象 或 null
</code></pre>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;
    &lt;script&gt;
        // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
        var timer = document.getElementById('time');
        console.log(timer);
        console.log(typeof timer);
        // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法
        console.dir(timer);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="132-根据标签名获取元素">1.3.2. 根据标签名获取元素</h3>
<pre><code>语法：document.getElementsByTagName('标签名') 或者 element.getElementsByTagName('标签名') 
作用：根据标签名获取元素对象
参数：标签名
返回值：元素对象集合（伪数组，数组元素是元素对象）
</code></pre>
<p><strong>案例代码</strong></p>
<pre><code class="language-javascript">&lt;body&gt;
    &lt;ul&gt;
        &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt;
        &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul id=&quot;nav&quot;&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
        &lt;li&gt;生僻字&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的
        var lis = document.getElementsByTagName('li');
        console.log(lis);
        console.log(lis[0]);
        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式
        for (var i = 0; i &lt; lis.length; i++) {
            console.log(lis[i]);
        }
        // 3. element.getElementsByTagName()  可以得到这个元素里面的某些标签
        var nav = document.getElementById('nav'); // 这个获得nav 元素
        var navLis = nav.getElementsByTagName('li');
        console.log(navLis);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="images/1550733441663.png" alt="1550733441663" loading="lazy"></figure>
<p>注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</p>
<h3 id="133-h5新增获取元素方式">1.3.3. H5新增获取元素方式</h3>
<figure data-type="image" tabindex="4"><img src="images/1550733518278.png" alt="1550733518278" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="images/1550733734425.png" alt="1550733734425" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;
    &lt;div id=&quot;nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;首页&lt;/li&gt;
            &lt;li&gt;产品&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. getElementsByClassName 根据类名获得某些元素集合
        var boxs = document.getElementsByClassName('box');
        console.log(boxs);
        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav
        var firstBox = document.querySelector('.box');
        console.log(firstBox);
        var nav = document.querySelector('#nav');
        console.log(nav);
        var li = document.querySelector('li');
        console.log(li);
        // 3. querySelectorAll()返回指定选择器的所有元素对象集合
        var allBox = document.querySelectorAll('.box');
        console.log(allBox);
        var lis = document.querySelectorAll('li');
        console.log(lis);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="134-获取特殊元素bodyhtml">1.3.4 获取特殊元素（body，html）</h3>
<figure data-type="image" tabindex="6"><img src="images/1550733794816.png" alt="1550733794816" loading="lazy"></figure>
<h2 id="14-事件基础">1.4. 事件基础</h2>
<h3 id="141-事件概述">1.4.1. 事件概述</h3>
<p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>
<p>简单理解： <strong>触发--- 响应机制</strong>。</p>
<p>​	网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p>
<h3 id="142-事件三要素">1.4.2. 事件三要素</h3>
<ul>
<li>事件源（谁）：触发事件的元素</li>
<li>事件类型（什么事件）： 例如 click 点击事件</li>
<li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li>
</ul>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;
    &lt;script&gt;
        // 点击一个按钮，弹出对话框
        // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素
        //(1) 事件源 事件被触发的对象   谁  按钮
        var btn = document.getElementById('btn');
        //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下
        //(3) 事件处理程序  通过一个函数赋值的方式 完成
        btn.onclick = function() {
            alert('点秋香');
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="143-执行事件的步骤">1.4.3. 执行事件的步骤</h3>
<figure data-type="image" tabindex="7"><img src="images/1550734387056.png" alt="1550734387056" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        // 执行事件步骤
        // 点击div 控制台输出 我被选中了
        // 1. 获取事件源
        var div = document.querySelector('div');
        // 2.绑定事件 注册事件
        // div.onclick 
        // 3.添加事件处理程序 
        div.onclick = function() {
            console.log('我被选中了');
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="144-常见的鼠标事件">1.4.4. 常见的鼠标事件</h3>
<figure data-type="image" tabindex="8"><img src="images/1550734506084.png" alt="1550734506084" loading="lazy"></figure>
<h3 id="145-分析事件三要素">1.4.5. 分析事件三要素</h3>
<ul>
<li>
<p>下拉菜单三要素</p>
</li>
<li>
<p>关闭广告三要素</p>
</li>
</ul>
<h2 id="15-操作元素">1.5. 操作元素</h2>
<p>​	JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p>
<h3 id="151-改变元素内容获取或设置">1.5.1. 改变元素内容（获取或设置）</h3>
<figure data-type="image" tabindex="9"><img src="images/1550735016756.png" alt="1550735016756" loading="lazy"></figure>
<p><strong>innerText改变元素内容</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;显示当前系统时间&lt;/button&gt;
    &lt;div&gt;某个时间&lt;/div&gt;
    &lt;p&gt;1123&lt;/p&gt;
    &lt;script&gt;
        // 当我们点击了按钮，  div里面的文字会发生变化
        // 1. 获取元素 
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        // 2.注册事件
        btn.onclick = function() {
            // div.innerText = '2019-6-6';
            div.innerHTML = getDate();
        }
        function getDate() {
            var date = new Date();
            // 我们写一个 2019年 5月 1日 星期三
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var dates = date.getDate();
            var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            var day = date.getDay();
            return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day];
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p><strong>innerText和innerHTML的区别</strong></p>
<ul>
<li>获取内容时的区别：</li>
</ul>
<p>​	innerText会去除空格和换行，而innerHTML会保留空格和换行</p>
<ul>
<li>设置内容时的区别：</li>
</ul>
<p>​	innerText不会识别html，而innerHTML会识别</p>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;p&gt;
        我是文字
        &lt;span&gt;123&lt;/span&gt;
    &lt;/p&gt;
    &lt;script&gt;
        // innerText 和 innerHTML的区别 
        // 1. innerText 不识别html标签 非标准  去除空格和换行
        var div = document.querySelector('div');
        // div.innerText = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';
        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的
        div.innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019';
        // 这两个属性是可读写的  可以获取元素里面的内容
        var p = document.querySelector('p');
        console.log(p.innerText);
        console.log(p.innerHTML);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="152-常用元素的属性操作">1.5.2. 常用元素的属性操作</h3>
<figure data-type="image" tabindex="10"><img src="images/1550735556297.png" alt="1550735556297" loading="lazy"></figure>
<p><strong>获取属性的值</strong></p>
<blockquote>
<p>元素对象.属性名</p>
</blockquote>
<p><strong>设置属性的值</strong></p>
<blockquote>
<p>元素对象.属性名 = 值</p>
</blockquote>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;
    &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt;
    &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt;
    &lt;script&gt;
        // 修改元素属性  src
        // 1. 获取元素
        var ldh = document.getElementById('ldh');
        var zxy = document.getElementById('zxy');
        var img = document.querySelector('img');
        // 2. 注册事件  处理程序
        zxy.onclick = function() {
            img.src = 'images/zxy.jpg';
            img.title = '张学友思密达';
        }
        ldh.onclick = function() {
            img.src = 'images/ldh.jpg';
            img.title = '刘德华';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="153-案例分时问候">1.5.3. 案例：分时问候</h3>
<figure data-type="image" tabindex="11"><img src="images/1550735858049.png" alt="1550735858049" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="images/1550735877145.png" alt="1550735877145" loading="lazy"></figure>
<h3 id="154-表单元素的属性操作">1.5.4. 表单元素的属性操作</h3>
<figure data-type="image" tabindex="13"><img src="images/1550736039005.png" alt="1550736039005" loading="lazy"></figure>
<p><strong>获取属性的值</strong></p>
<blockquote>
<p>元素对象.属性名</p>
</blockquote>
<p><strong>设置属性的值</strong></p>
<blockquote>
<p>元素对象.属性名 = 值</p>
<p>表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。</p>
</blockquote>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;按钮&lt;/button&gt;
    &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var input = document.querySelector('input');
        // 2. 注册事件 处理程序
        btn.onclick = function() {
            // 表单里面的值 文字内容是通过 value 来修改的
            input.value = '被点击了';
            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用
            // btn.disabled = true;
            this.disabled = true;
            // this 指向的是事件函数的调用者 btn
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="155-案例仿京东显示密码">1.5.5. 案例：仿京东显示密码</h3>
<figure data-type="image" tabindex="14"><img src="images/1550736330331.png" alt="1550736330331" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="images/1550736346822.png" alt="1550736346822" loading="lazy"></figure>
<h3 id="156-样式属性操作">1.5.6. 样式属性操作</h3>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<p><strong>常用方式</strong></p>
<figure data-type="image" tabindex="16"><img src="images/1550736488634.png" alt="1550736488634" loading="lazy"></figure>
<h4 id="方式1通过操作style属性">方式1：通过操作style属性</h4>
<blockquote>
<p>元素对象的style属性也是一个对象！</p>
<p>元素对象.style.样式属性 = 值;</p>
</blockquote>
<figure data-type="image" tabindex="17"><img src="images/1550736620181.png" alt="1550736620181" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素
        var div = document.querySelector('div');
        // 2. 注册事件 处理程序
        div.onclick = function() {
            // div.style里面的属性 采取驼峰命名法 
            this.style.backgroundColor = 'purple';
            this.style.width = '250px';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="案例淘宝点击关闭二维码">案例：淘宝点击关闭二维码</h4>
<figure data-type="image" tabindex="18"><img src="images/1550736843659.png" alt="1550736843659" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="images/1550736881832.png" alt="1550736881832" loading="lazy"></figure>
<h4 id="案例循环精灵图背景">案例：循环精灵图背景</h4>
<figure data-type="image" tabindex="20"><img src="images/1550736940082.png" alt="1550736940082" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="images/1550736956754.png" alt="1550736956754" loading="lazy"></figure>
<h4 id="案例显示隐藏文本框内容">案例：显示隐藏文本框内容</h4>
<figure data-type="image" tabindex="22"><img src="images/1550737006593.png" alt="1550737006593" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="images/1550737019729.png" alt="1550737019729" loading="lazy"></figure>
<h4 id="方式2通过操作classname属性">方式2：通过操作className属性</h4>
<blockquote>
<p>元素对象.className = 值;</p>
<p>因为class是关键字，所有使用className。</p>
</blockquote>
<figure data-type="image" tabindex="24"><img src="images/1550737214510.png" alt="1550737214510" loading="lazy"></figure>
<p><strong>案例代码</strong></p>
<pre><code class="language-js">&lt;body&gt;
    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;
    &lt;script&gt;
        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用
        var test = document.querySelector('div');
        test.onclick = function() {
            // this.style.backgroundColor = 'purple';
            // this.style.color = '#fff';
            // this.style.fontSize = '25px';
            // this.style.marginTop = '100px';

            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
            // this.className = 'change';
            this.className = 'first change';
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="案例密码框格式提示错误信息">案例：密码框格式提示错误信息</h4>
<figure data-type="image" tabindex="25"><img src="images/1550737269546.png" alt="1550737269546" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="images/1550737284218.png" alt="1550737284218" loading="lazy"></figure>
<h2 id="16-今日总结">1.6. 今日总结</h2>
<figure data-type="image" tabindex="27"><img src="images/1550737354861.png" alt="1550737354861" loading="lazy"></figure>
<h1 id="day02-web-apis">day02 - Web APIs</h1>
<blockquote>
<p>学习目标：</p>
<p>能够说出排他操作的一般实现步骤</p>
<p>能够使用html5中的dataset方式操作自定义属性</p>
<p>能够根据提示完成百度换肤的案例</p>
<p>能够根据提示完成全选案例</p>
<p>能够根据提示完成tab栏切换案例</p>
<p>能够区分元素节点、文本节点、属性节点</p>
<p>能够获取指定元素的父元素</p>
<p>能够获取指定元素的所有子元素</p>
<p>能够说出childNodes和children的区别</p>
<p>能够使用createElement创建页面元素</p>
</blockquote>
<h2 id="11-排他操作">1.1. 排他操作</h2>
<h3 id="111-排他思想">1.1.1 排他思想</h3>
<p>![1550914482628](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550914482628.png)</p>
<p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：</p>
<ol>
<li>
<p>所有元素全部清除样式（干掉其他人）</p>
</li>
<li>
<p>给当前元素设置样式 （留下我自己）</p>
</li>
<li>
<p>注意顺序不能颠倒，首先干掉其他人，再设置自己</p>
</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;按钮1&lt;/button&gt;
    &lt;button&gt;按钮2&lt;/button&gt;
    &lt;button&gt;按钮3&lt;/button&gt;
    &lt;button&gt;按钮4&lt;/button&gt;
    &lt;button&gt;按钮5&lt;/button&gt;
    &lt;script&gt;
        // 1. 获取所有按钮元素
        var btns = document.getElementsByTagName('button');
        // btns得到的是伪数组  里面的每一个元素 btns[i]
        for (var i = 0; i &lt; btns.length; i++) {
            btns[i].onclick = function() {
                // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人
                for (var i = 0; i &lt; btns.length; i++) {
                    btns[i].style.backgroundColor = '';
                }
                // (2) 然后才让当前的元素背景颜色为pink 留下我自己
                this.style.backgroundColor = 'pink';

            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="12-案例百度换肤">1.2 案例：百度换肤</h2>
<p>![1550914640677](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550914640677.png)</p>
<p>![1550914663042](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550914663042.png)</p>
<pre><code class="language-js">&lt;body&gt;
    &lt;ul class=&quot;baidu&quot;&gt;
        &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素 
        var imgs = document.querySelector('.baidu').querySelectorAll('img');
        // console.log(imgs);
        // 2. 循环注册事件 
        for (var i = 0; i &lt; imgs.length; i++) {
            imgs[i].onclick = function() {
                // this.src 就是我们点击图片的路径   images/2.jpg
                // console.log(this.src);
                // 把这个路径 this.src 给body 就可以了
                document.body.style.backgroundImage = 'url(' + this.src + ')';
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="13-案例表格隔行变色">1.3 案例：表格隔行变色</h2>
<p>![1550914791881](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550914791881.png)</p>
<p>![1550914812202](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550914812202.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 1.获取元素 获取的是 tbody 里面所有的行
        var trs = document.querySelector('tbody').querySelectorAll('tr');
        // 2. 利用循环绑定注册事件
        for (var i = 0; i &lt; trs.length; i++) {
            // 3. 鼠标经过事件 onmouseover
            trs[i].onmouseover = function() {
                    // console.log(11);
                    this.className = 'bg';
                }
                // 4. 鼠标离开事件 onmouseout
            trs[i].onmouseout = function() {
                this.className = '';
            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="14-案例全选">1.4 案例：全选</h2>
<p>![1550914980274](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550914980274.png)</p>
<p>![1550915005393](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915005393.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可
        // 获取元素
        
        var j_cbAll = document.getElementById('j_cbAll'); 
        var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); 
        // 全选按钮注册事件
        j_cbAll.onclick = function() {
                // this.checked 当前复选框的选中状态
                console.log(this.checked);
                for (var i = 0; i &lt; j_tbs.length; i++) {
                    j_tbs[i].checked = this.checked;
                }
         }
         // 给所有的子复选框注册单击事件
        for (var i = 0; i &lt; j_tbs.length; i++) {
            j_tbs[i].onclick = function() {
                // flag 控制全选按钮是否选中
                var flag = true;
                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
                for (var i = 0; i &lt; j_tbs.length; i++) {
                    if (!j_tbs[i].checked) {
                        flag = false;
                        break; 
                    }
                }
                // 设置全选按钮的状态
                j_cbAll.checked = flag;
            }
        }
    &lt;/script&gt;
</code></pre>
<h2 id="15-自定义属性操作">1.5. 自定义属性操作</h2>
<h3 id="151-获取属性值">1.5.1 获取属性值</h3>
<p>![1550915376339](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915376339.png)</p>
<pre><code class="language-js">    &lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // 1. 获取元素的属性值
        // (1) element.属性
        console.log(div.id);
        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
	&lt;/script&gt;
</code></pre>
<h3 id="152-设置属性值">1.5.2. 设置属性值</h3>
<p>![1550915445026](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915445026.png)</p>
<pre><code class="language-js">        // 2. 设置元素属性值
        // (1) element.属性= '值'
        div.id = 'test';
        div.className = 'navs';
        // (2) element.setAttribute('属性', '值');  主要针对于自定义属性
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是
</code></pre>
<h3 id="153-移出属性">1.5.3. 移出属性</h3>
<p>![1550915513137](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915513137.png)</p>
<pre><code class="language-js">		// class 不是className
        // 3 移除属性 removeAttribute(属性)    
        div.removeAttribute('index');
</code></pre>
<h3 id="154-案例tab栏">1.5.4. 案例：tab栏</h3>
<p>![1550915567627](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915567627.png)</p>
<p>![1550915590707](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915590707.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 获取元素
        var tab_list = document.querySelector('.tab_list');
        var lis = tab_list.querySelectorAll('li');
        var items = document.querySelectorAll('.item');
        // for循环，给选项卡绑定点击事件
        for (var i = 0; i &lt; lis.length; i++) {
            // 开始给5个小li 设置索引号 
            lis[i].setAttribute('index', i);
            lis[i].onclick = function() {
                // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）
                // 干掉所有人 其余的li清除 class 这个类
                for (var i = 0; i &lt; lis.length; i++) {
                    lis[i].className = '';
                }
                // 留下我自己 
                this.className = 'current';
                // 2. 下面的显示内容模块
                var index = this.getAttribute('index');
                console.log(index);
                // 干掉所有人 让其余的item 这些div 隐藏
                for (var i = 0; i &lt; items.length; i++) {
                    items[i].style.display = 'none';
                }
                // 留下我自己 让对应的item 显示出来
                items[index].style.display = 'block';
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="155-h5自定义属性">1.5.5. H5自定义属性</h3>
<p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</p>
<p>自定义属性获取是通过getAttribute(‘属性’) 获取。</p>
<p>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</p>
<p>H5给我们新增了自定义属性：</p>
<p>![1550915798516](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915798516.png)</p>
<p>![1550915815571](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550915815571.png)</p>
<pre><code class="language-js">    &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // console.log(div.getTime);
        console.log(div.getAttribute('getTime'));
        div.setAttribute('data-time', 20);
        console.log(div.getAttribute('data-index'));
        console.log(div.getAttribute('data-list-name'));
        // h5新增的获取自定义属性的方法 它只能获取data-开头的
        // dataset 是一个集合里面存放了所有以data开头的自定义属性
        console.log(div.dataset);
        console.log(div.dataset.index);
        console.log(div.dataset['index']);
        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法
        console.log(div.dataset.listName);
        console.log(div.dataset['listName']);
    &lt;/script&gt;
</code></pre>
<h2 id="16-节点操作">1.6. 节点操作</h2>
<h3 id="161-节点概述">1.6.1. 节点概述</h3>
<p>​	网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p>
<p>​	HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p>
<p>![1550970944363](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550970944363.png)</p>
<p>​	一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p>
<p>![1550970986988](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550970986988.png)</p>
<h3 id="162-节点层级">1.6.2. 节点层级</h3>
<p>​	利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p>
<p>​    ![1550971058781](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550971058781.png)</p>
<h3 id="163-父级节点">1.6.3. 父级节点</h3>
<p>![1550971196686](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550971196686.png)</p>
<pre><code class="language-js">    &lt;div class=&quot;demo&quot;&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. 父节点 parentNode
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
        console.log(erweima.parentNode);
    &lt;/script&gt;
</code></pre>
<h3 id="164-子节点">1.6.4. 子节点</h3>
<p><strong>所有子节点</strong></p>
<p>![1550971263925](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550971263925.png)</p>
<p><strong>子元素节点</strong></p>
<p>![1550971325828](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550971325828.png)</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
        &lt;li&gt;我是li&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // DOM 提供的方法（API）获取
        var ul = document.querySelector('ul');
        var lis = ul.querySelectorAll('li');
        // 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等
        console.log(ul.childNodes);
        console.log(ul.childNodes[0].nodeType);
        console.log(ul.childNodes[1].nodeType);
        // 2. children 获取所有的子元素节点 也是我们实际开发常用的
        console.log(ul.children);
    &lt;/script&gt;
</code></pre>
<p><strong>第1个子节点</strong></p>
<p>![1550971774758](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550971774758.png)</p>
<p><strong>最后1个子节点</strong></p>
<p>![1550971825493](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550971825493.png)</p>
<p><strong>第1个子元素节点</strong></p>
<p>![1550972014509](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550972014509.png)</p>
<p><strong>最后1个子元素节点</strong></p>
<p>![1550972106485](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550972106485.png)</p>
<p>​	实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p>
<p>![1550972648014](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550972648014.png)</p>
<pre><code class="language-js">    &lt;ol&gt;
        &lt;li&gt;我是li1&lt;/li&gt;
        &lt;li&gt;我是li2&lt;/li&gt;
        &lt;li&gt;我是li3&lt;/li&gt;
        &lt;li&gt;我是li4&lt;/li&gt;
        &lt;li&gt;我是li5&lt;/li&gt;
    &lt;/ol&gt;
    &lt;script&gt;
        var ol = document.querySelector('ol');
        // 1. firstChild 第一个子节点 不管是文本节点还是元素节点
        console.log(ol.firstChild);
        console.log(ol.lastChild);
        // 2. firstElementChild 返回第一个子元素节点 ie9才支持
        console.log(ol.firstElementChild);
        console.log(ol.lastElementChild);
        // 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素
        console.log(ol.children[0]);
        console.log(ol.children[ol.children.length - 1]);
    &lt;/script&gt;
</code></pre>
<h3 id="165-案例新浪下拉菜单">1.6.5. 案例：新浪下拉菜单</h3>
<p>![</p>
<p>](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550974934894.png)</p>
<p>![1550975025608](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550975025608.png)</p>
<p>![1550975049176](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550975049176.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 1. 获取元素
        var nav = document.querySelector('.nav');
        var lis = nav.children; // 得到4个小li
        // 2.循环注册事件
        for (var i = 0; i &lt; lis.length; i++) {
            lis[i].onmouseover = function() {
                this.children[1].style.display = 'block';
            }
            lis[i].onmouseout = function() {
                this.children[1].style.display = 'none';
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="166-兄弟节点">1.6.6. 兄弟节点</h3>
<p><strong>下一个兄弟节点</strong></p>
<p>![1550973538696](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day02\4-笔记\images\1550973538696.png)</p>
<p><strong>上一个兄弟节点</strong></p>
<p>![1550973558511](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day02\4-笔记\images\1550973558511.png)</p>
<pre><code class="language-js">    &lt;div&gt;我是div&lt;/div&gt;
    &lt;span&gt;我是span&lt;/span&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等
        console.log(div.nextSibling);
        console.log(div.previousSibling);
        // 2. nextElementSibling 得到下一个兄弟元素节点
        console.log(div.nextElementSibling);
        console.log(div.previousElementSibling);
    &lt;/script&gt;
</code></pre>
<p><strong>下一个兄弟元素节点（有兼容性问题）</strong></p>
<p>![1550973610223](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day02\4-笔记\images\1550973610223.png)</p>
<p><strong>上一个兄弟元素节点（有兼容性问题）</strong></p>
<p>![1550973630150](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day02\4-笔记\images\1550973630150.png)</p>
<p>![1550973722805](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day02\4-笔记\images\1550973722805.png)</p>
<p>![1550973799759](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day02\4-笔记\images\1550973799759.png)</p>
<pre><code class="language-js">   function getNextElementSibling(element) {
      var el = element;
      while (el = el.nextSibling) {
        if (el.nodeType === 1) {
            return el;
        }
      }
      return null;
    }  
</code></pre>
<h3 id="167-创建节点">1.6.7. 创建节点</h3>
<p>![1550975514321](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550975514321.png)z</p>
<h3 id="168-添加节点">1.6.8. 添加节点</h3>
<p>![1550975640170](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550975640170.png)</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;123&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 创建节点元素节点
        var li = document.createElement('li');
        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素);
        var lili = document.createElement('li');
        ul.insertBefore(lili, ul.children[0]);
        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
    &lt;/script&gt;
</code></pre>
<h3 id="169-案例简单版发布留言">1.6.9. 案例：简单版发布留言</h3>
<p>![1550975849302](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550975849302.png)</p>
<p>![1550975887017](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day02/4-笔记/images/1550975887017.png)</p>
<pre><code class="language-js">&lt;body&gt;
    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
    &lt;ul&gt;

    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h1 id="day03-web-apis">day03 - Web APIs</h1>
<blockquote>
<p>学习目标：</p>
<p>能够使用removeChild()方法删除节点</p>
<p>能够完成动态生成表格案例</p>
<p>能够使用传统方式和监听方式给元素注册事件</p>
<p>能够说出事件流执行的三个阶段</p>
<p>能够在事件处理函数中获取事件对象</p>
<p>能够使用事件对象取消默认行为</p>
<p>能够使用事件对象阻止事件冒泡</p>
<p>能够使用事件对象获取鼠标的位置</p>
<p>能够完成跟随鼠标的天使案例</p>
</blockquote>
<h2 id="11-节点操作">1.1. 节点操作</h2>
<h3 id="111-删除节点">1.1.1 删除节点</h3>
<p>![1551163384254](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day03\4-笔记\images\1551163384254(1).png)</p>
<p>node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</p>
<pre><code class="language-js">    &lt;button&gt;删除&lt;/button&gt;
    &lt;ul&gt;
        &lt;li&gt;熊大&lt;/li&gt;
        &lt;li&gt;熊二&lt;/li&gt;
        &lt;li&gt;光头强&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 1.获取元素
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2. 删除元素  node.removeChild(child)
        // ul.removeChild(ul.children[0]);
        // 3. 点击按钮依次删除里面的孩子
        btn.onclick = function() {
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="112-案例删除留言">1.1.2 案例：删除留言</h3>
<p>![1551163586475](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551163586475.png)</p>
<p>![1551163635501](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551163635501.png)</p>
<pre><code class="language-js">    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
    &lt;ul&gt;

    &lt;/ul&gt;
    &lt;script&gt;
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value + &quot;&lt;a href='javascript:;'&gt;删除&lt;/a&gt;&quot;;
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
                // (3) 删除元素 删除的是当前链接的li  它的父亲
                var as = document.querySelectorAll('a');
                for (var i = 0; i &lt; as.length; i++) {
                    as[i].onclick = function() {
                        // 删除的是 li 当前a所在的li  this.parentNode;
                        ul.removeChild(this.parentNode);
                    }
                }
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="113-复制克隆节点">1.1.3 复制（克隆）节点</h3>
<p>![1551163763825](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551163763825.png)</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;1111&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.querySelector('ul');
        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
        var lili = ul.children[0].cloneNode(true);
        ul.appendChild(lili);
    &lt;/script&gt;
</code></pre>
<h3 id="114-案例动态生成表格">1.1.4 案例：动态生成表格</h3>
<p>![1551163900675](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551163900675.png)</p>
<p>![1551163924396](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551163924396.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 1.先去准备好学生的数据
        var datas = [{
            name: '魏璎珞',
            subject: 'JavaScript',
            score: 100
        }, {
            name: '弘历',
            subject: 'JavaScript',
            score: 98
        }, {
            name: '傅恒',
            subject: 'JavaScript',
            score: 99
        }, {
            name: '明玉',
            subject: 'JavaScript',
            score: 88
        }, {
            name: '大猪蹄子',
            subject: 'JavaScript',
            score: 0
        }];
        // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行
        var tbody = document.querySelector('tbody');
		// 遍历数组
        for (var i = 0; i &lt; datas.length; i++) { 
            // 1. 创建 tr行
            var tr = document.createElement('tr');
            tbody.appendChild(tr);
            // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数  
            // 使用for in遍历学生对象
            for (var k in datas[i]) { 
                // 创建单元格 
                var td = document.createElement('td');
                // 把对象里面的属性值 datas[i][k] 给 td  
                td.innerHTML = datas[i][k];
                tr.appendChild(td);
            }
            // 3. 创建有删除2个字的单元格 
            var td = document.createElement('td');
            td.innerHTML = '&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;';
            tr.appendChild(td);

        }
        // 4. 删除操作 开始 
        var as = document.querySelectorAll('a');
        for (var i = 0; i &lt; as.length; i++) {
            as[i].onclick = function() {
                // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)  
                tbody.removeChild(this.parentNode.parentNode)
            }
        }
    &lt;/script&gt;
</code></pre>
<h3 id="115-创建元素的三种方式">1.1.5 创建元素的三种方式</h3>
<p>![1551164214925](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164214925.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 三种创建元素方式区别 
        // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘
         var btn = document.querySelector('button');
         btn.onclick = function() {
             document.write('&lt;div&gt;123&lt;/div&gt;');
         }

        // 2. innerHTML 创建元素
        var inner = document.querySelector('.inner');
         for (var i = 0; i &lt;= 100; i++) {
             inner.innerHTML += '&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;'
         }
        var arr = [];
        for (var i = 0; i &lt;= 100; i++) {
            arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;');
        }
        inner.innerHTML = arr.join('');
        // 3. document.createElement() 创建元素
        var create = document.querySelector('.create');
        for (var i = 0; i &lt;= 100; i++) {
            var a = document.createElement('a');
            create.appendChild(a);
        }
    &lt;/script&gt;
</code></pre>
<h3 id="116-innerthml和createelement效率对比">1.1.6 innerTHML和createElement效率对比</h3>
<p><strong>innerHTML字符串拼接方式（效率低）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();
        var str = '';
        for (var i = 0; i &lt; 1000; i++) {
            document.body.innerHTML += '&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;';
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<p><strong>createElement方式（效率一般）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();

        for (var i = 0; i &lt; 1000; i++) {
            var div = document.createElement('div');
            div.style.width = '100px';
            div.style.height = '2px';
            div.style.border = '1px solid red';
            document.body.appendChild(div);
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<p><strong>innerHTML数组方式（效率高）</strong></p>
<pre><code class="language-js">&lt;script&gt;
    function fn() {
        var d1 = +new Date();
        var array = [];
        for (var i = 0; i &lt; 1000; i++) {
            array.push('&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;');
        }
        document.body.innerHTML = array.join('');
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
&lt;/script&gt;
</code></pre>
<h2 id="12-dom的核心总结">1.2. DOM的核心总结</h2>
<p>![1551164669434](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164669434.png)</p>
<p>![1551164715018](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164715018.png)</p>
<p>关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</p>
<h3 id="121-创建">1.2.1. 创建</h3>
<p>![1551164797164](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164797164.png)</p>
<h3 id="122-增加">1.2.2. 增加</h3>
<p>![1551164829832](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164829832.png)</p>
<h3 id="123-删">1.2.3. 删</h3>
<p>![1551164872533](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164872533.png)</p>
<h3 id="124-改">1.2.4. 改</h3>
<p>![1551164907830](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164907830.png)</p>
<h3 id="125-查">1.2.5. 查</h3>
<p>![1551164936214](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164936214.png)</p>
<h3 id="126-属性操作">1.2.6. 属性操作</h3>
<p>![1551164985383](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551164985383.png)</p>
<h3 id="127-事件操作重点">1.2.7. 事件操作（重点）</h3>
<h2 id="13-事件高级">1.3. 事件高级</h2>
<h3 id="131-注册事件2种方式">1.3.1. 注册事件（2种方式）</h3>
<p>![1551165252019](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551165252019.png)</p>
<h3 id="132-事件监听">1.3.2 事件监听</h3>
<h4 id="c">c</h4>
<p>![1551165364122](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551165364122.png)</p>
<p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p>
<p>![1551165604792](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551165604792.png)</p>
<h4 id="attacheevent事件监听ie678支持">attacheEvent()事件监听（IE678支持）</h4>
<p>![1551165781836](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551165781836.png)</p>
<p>​	eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p>
<p>![1551165843912](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551165843912.png)</p>
<pre><code class="language-js">&lt;button&gt;传统注册事件&lt;/button&gt;
&lt;button&gt;方法监听注册事件&lt;/button&gt;
&lt;button&gt;ie9 attachEvent&lt;/button&gt;
&lt;script&gt;
    var btns = document.querySelectorAll('button');
    // 1. 传统方式注册事件
    btns[0].onclick = function() {
        alert('hi');
    }
    btns[0].onclick = function() {
            alert('hao a u');
        }
   // 2. 事件侦听注册事件 addEventListener 
   // (1) 里面的事件类型是字符串 必定加引号 而且不带on
   // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）
    btns[1].addEventListener('click', function() {
        alert(22);
    })
    btns[1].addEventListener('click', function() {
            alert(33);
    })
    // 3. attachEvent ie9以前的版本支持
    btns[2].attachEvent('onclick', function() {
        alert(11);
    })
&lt;/script&gt;
</code></pre>
<h4 id="事件监听兼容性解决方案">事件监听兼容性解决方案</h4>
<p>封装一个函数，函数中判断浏览器的类型：</p>
<p>![1551166023885](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551166023885.png)</p>
<h3 id="133-删除事件解绑事件">1.3.3. 删除事件（解绑事件）</h3>
<p>![1551166185410](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551166185410.png)</p>
<pre><code class="language-js">    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
    &lt;div&gt;3&lt;/div&gt;
    &lt;script&gt;
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        // 2. removeEventListener 删除事件
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号
        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        // 3. detachEvent
        divs[2].attachEvent('onclick', fn1);

        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
    &lt;/script&gt;
</code></pre>
<p>**删除事件兼容性解决方案 **</p>
<p>![1551166332453](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551166332453.png)</p>
<h3 id="134-dom事件流">1.3.4. DOM事件流</h3>
<blockquote>
<pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。
当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。

那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？
</code></pre>
</blockquote>
<p>![1551166423144](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551166423144.png)</p>
<blockquote>
<p>比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</p>
</blockquote>
<p>![1551166555833](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551166555833.png)</p>
<p>![1551166581552](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551166581552.png)</p>
<blockquote>
<pre><code>当时的2大浏览器霸主谁也不服谁！
IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。
Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。

江湖纷争，武林盟主也脑壳疼！！！

最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。
现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。
</code></pre>
</blockquote>
<p>DOM 事件流会经历3个阶段：</p>
<ol>
<li>
<p>捕获阶段</p>
</li>
<li>
<p>当前目标阶段</p>
</li>
<li>
<p>冒泡阶段</p>
</li>
</ol>
<p>​	我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</p>
<p>![1551169007768](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551169007768.png)</p>
<p>![1551169042295](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551169042295.png)</p>
<p><strong>事件冒泡</strong></p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // onclick 和 attachEvent（ie） 在冒泡阶段触发
        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 
        // son -&gt; father -&gt;body -&gt; html -&gt; document
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function() {
            alert('son');
        }, false);
		// 给father注册单击事件
        var father = document.querySelector('.father');
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件，省略第3个参数
        document.addEventListener('click', function() {
            alert('document');
        })
    &lt;/script&gt;
</code></pre>
<p><strong>事件捕获</strong></p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发
        // document -&gt; html -&gt; body -&gt; father -&gt; son
         var son = document.querySelector('.son');
		// 给son注册单击事件，第3个参数为true
         son.addEventListener('click', function() {
             alert('son');
         }, true);
         var father = document.querySelector('.father');
		// 给father注册单击事件，第3个参数为true
         father.addEventListener('click', function() {
             alert('father');
         }, true);
		// 给document注册单击事件，第3个参数为true
        document.addEventListener('click', function() {
            alert('document');
        }, true)
    &lt;/script&gt;
</code></pre>
<h3 id="135-事件对象">1.3.5. 事件对象</h3>
<h4 id="什么是事件对象">什么是事件对象</h4>
<p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</p>
<p>比如：</p>
<ol>
<li>
<p>谁绑定了这个事件。</p>
</li>
<li>
<p>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</p>
</li>
<li>
<p>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</p>
</li>
</ol>
<h4 id="事件对象的使用">事件对象的使用</h4>
<p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</p>
<p>所以，在事件处理函数中声明1个形参用来接收事件对象。</p>
<p>![1551169537789](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551169537789.png)</p>
<h4 id="事件对象的兼容性处理">事件对象的兼容性处理</h4>
<p>事件对象本身的获取存在兼容问题：</p>
<ol>
<li>
<p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p>
</li>
<li>
<p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</p>
</li>
</ol>
<p>![1551169680823](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551169680823.png)</p>
<pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。
只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。
</code></pre>
<pre><code class="language-js">    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        div.onclick = function(e) {
                // 事件对象
                e = e || window.event;
                console.log(e);
        }
    &lt;/script&gt;
</code></pre>
<h4 id="事件对象的属性和方法">事件对象的属性和方法</h4>
<p>![1551169931778](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551169931778.png)</p>
<h4 id="etarget-和-this-的区别">e.target 和 this 的区别</h4>
<ul>
<li>
<p>this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</p>
</li>
<li>
<p>e.target 是事件触发的元素。</p>
</li>
</ul>
<blockquote>
<pre><code>常情况下terget 和 this是一致的，
但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），
	这时候this指向的是父元素，因为它是绑定事件的元素对象，
	而target指向的是子元素，因为他是触发事件的那个具体元素对象。
</code></pre>
</blockquote>
<pre><code class="language-js">    &lt;div&gt;123&lt;/div&gt;
    &lt;script&gt;
        var div = document.querySelector('div');
        div.addEventListener('click', function(e) {
            // e.target 和 this指向的都是div
            console.log(e.target);
            console.log(this);

        });
    &lt;/script&gt;
</code></pre>
<p>事件冒泡下的e.target和this</p>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;abc&lt;/li&gt;
        &lt;li&gt;abc&lt;/li&gt;
        &lt;li&gt;abc&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
              // 我们给ul 绑定了事件  那么this 就指向ul  
              console.log(this); // ul

              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li
              console.log(e.target); // li
        });
    &lt;/script&gt;
</code></pre>
<h3 id="136-阻止默认行为">1.3.6 阻止默认行为</h3>
<blockquote>
<p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p>
</blockquote>
<pre><code class="language-js">    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;
    &lt;script&gt;
        // 2. 阻止默认行为 让链接不跳转 
        var a = document.querySelector('a');
        a.addEventListener('click', function(e) {
             e.preventDefault(); //  dom 标准写法
        });
        // 3. 传统的注册方式
        a.onclick = function(e) {
            // 普通浏览器 e.preventDefault();  方法
            e.preventDefault();
            // 低版本浏览器 ie678  returnValue  属性
            e.returnValue = false;
            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题
            return false;
        }
    &lt;/script&gt;
</code></pre>
<h3 id="137-阻止事件冒泡">1.3.7 阻止事件冒泡</h3>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p>
<p>![1551171467194](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551171467194.png)</p>
<pre><code class="language-js">    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var son = document.querySelector('.son');
		// 给son注册单击事件
        son.addEventListener('click', function(e) {
            alert('son');
            e.stopPropagation(); // stop 停止  Propagation 传播
            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡
        }, false);

        var father = document.querySelector('.father');
		// 给father注册单击事件
        father.addEventListener('click', function() {
            alert('father');
        }, false);
		// 给document注册单击事件
        document.addEventListener('click', function() {
            alert('document');
        })
    &lt;/script&gt;
</code></pre>
<p><strong>阻止事件冒泡的兼容性处理</strong></p>
<p>![1551171657513](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551171657513.png)</p>
<h3 id="138-事件委托">1.3.8 事件委托</h3>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p>
<h4 id="什么是事件委托">什么是事件委托</h4>
<pre><code>把事情委托给别人，代为处理。
</code></pre>
<p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p>
<blockquote>
<p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p>
</blockquote>
<p><strong>生活中的代理：</strong></p>
<p>![1551172082624](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551172082624.png)</p>
<p><strong>js事件中的代理：</strong></p>
<p>![1551172159273](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551172159273.png)</p>
<h4 id="事件委托的原理">事件委托的原理</h4>
<p>​	给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p>
<h4 id="事件委托的作用">事件委托的作用</h4>
<ul>
<li>
<p>我们只操作了一次 DOM ，提高了程序的性能。</p>
</li>
<li>
<p>动态新创建的子元素，也拥有事件。</p>
</li>
</ul>
<pre><code class="language-js">    &lt;ul&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function(e) {
            // e.target 这个可以得到我们点击的对象
            e.target.style.backgroundColor = 'pink';
        })
    &lt;/script&gt;
</code></pre>
<h2 id="14-常用鼠标事件">1.4. 常用鼠标事件</h2>
<p>![1551172699854](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551172699854.png)</p>
<h3 id="141-案例禁止选中文字和禁止右键菜单">1.4.1 案例：禁止选中文字和禁止右键菜单</h3>
<p>![1551172755484](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551172755484.png)</p>
<pre><code class="language-js">&lt;body&gt;
    我是一段不愿意分享的文字
    &lt;script&gt;
        // 1. contextmenu 我们可以禁用右键菜单
        document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
        })
        // 2. 禁止选中文字 selectstart
        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="142-鼠标事件对象">1.4.2 鼠标事件对象</h3>
<p>![1551173103741](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551173103741.png)</p>
<h3 id="143-获取鼠标在页面的坐标">1.4.3 获取鼠标在页面的坐标</h3>
<pre><code class="language-js">    &lt;script&gt;
        // 鼠标事件对象 MouseEvent
        document.addEventListener('click', function(e) {
            // 1. client 鼠标在可视区的x和y坐标
            console.log(e.clientX);
            console.log(e.clientY);
            console.log('---------------------');

            // 2. page 鼠标在页面文档的x和y坐标
            console.log(e.pageX);
            console.log(e.pageY);
            console.log('---------------------');

            // 3. screen 鼠标在电脑屏幕的x和y坐标
            console.log(e.screenX);
            console.log(e.screenY);

        })
    &lt;/script&gt;
</code></pre>
<h3 id="144-案例跟随鼠标的天使">1.4.4 案例：跟随鼠标的天使</h3>
<p>![1551173172613](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551173172613.png)</p>
<p>![1551173186812](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day03/4-笔记/images/1551173186812.png)</p>
<pre><code class="language-js">    &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;
    &lt;script&gt;
        var pic = document.querySelector('img');
        document.addEventListener('mousemove', function(e) {
        	// 1. mousemove只要我们鼠标移动1px 就会触发这个事件
        	// 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 
            // 把这个x和y坐标做为图片的top和left 值就可以移动图片
        	var x = e.pageX;
        	var y = e.pageY;
        	console.log('x坐标是' + x, 'y坐标是' + y);
        	//3 . 千万不要忘记给left 和top 添加px 单位
        	pic.style.left = x - 50 + 'px';
        	pic.style.top = y - 40 + 'px';
    	});
    &lt;/script&gt;
</code></pre>
<h1 id="day04-web-apis">day04 - Web APIs</h1>
<blockquote>
<p>学习目标：</p>
<p>能够说出常用的3-5个键盘事件</p>
<p>能够知道如何获取当前键盘按下的是哪个键</p>
<p>能够知道浏览器的顶级对象window</p>
<p>能够使用window.onload事件</p>
<p>能够使用window.onresize事件</p>
<p>能够说出两种定时器的区别</p>
<p>能够使用location对象的href属性完成页面之间的跳转</p>
<p>能够使用location对象获取url中的参数部分</p>
<p>能够使用history提供的方法实现页面刷新</p>
</blockquote>
<h2 id="11-常用的键盘事件">1.1. 常用的键盘事件</h2>
<h3 id="111-键盘事件">1.1.1 键盘事件</h3>
<p>![1551318122855](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318122855.png)</p>
<p>![1551318160371](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318160371.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 常用的键盘事件
        //1. keyup 按键弹起的时候触发 
        document.addEventListener('keyup', function() {
            console.log('我弹起了');
        })

        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊
        document.addEventListener('keypress', function() {
                console.log('我按下了press');
        })
        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊
        document.addEventListener('keydown', function() {
                console.log('我按下了down');
        })
        // 4. 三个事件的执行顺序  keydown -- keypress -- keyup
    &lt;/script&gt;
</code></pre>
<h3 id="112-键盘事件对象">1.1.2 键盘事件对象</h3>
<p>![1551318355505](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318355505.png)</p>
<p>![1551318404238](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318404238.png)</p>
<p><strong>使用keyCode属性判断用户按下哪个键</strong></p>
<pre><code class="language-js">    &lt;script&gt;
        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值
        document.addEventListener('keyup', function(e) {
            console.log('up:' + e.keyCode);
            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键
            if (e.keyCode === 65) {
                alert('您按下的a键');
            } else {
                alert('您没有按下a键')
            }
        })
        document.addEventListener('keypress', function(e) {
            // console.log(e);
            console.log('press:' + e.keyCode);
        })
    &lt;/script&gt;
</code></pre>
<h3 id="113-案例模拟京东按键输入内容">1.1.3 案例：模拟京东按键输入内容</h3>
<p>当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</p>
<p>![1551318669520](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318669520.png)</p>
<blockquote>
<p>注意：触发获得焦点事件，可以使用 元素对象.focus()</p>
</blockquote>
<pre><code class="language-js">    &lt;input type=&quot;text&quot;&gt;
    &lt;script&gt;
        // 获取输入框
        var search = document.querySelector('input');
		// 给document注册keyup事件
        document.addEventListener('keyup', function(e) {
            // 判断keyCode的值
            if (e.keyCode === 83) {
                // 触发输入框的获得焦点事件
                search.focus();
            }
        })
    &lt;/script&gt;
</code></pre>
<h3 id="114-案例模拟京东快递单号查询">1.1.4 案例：模拟京东快递单号查询</h3>
<p>要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</p>
<p>![1551318882189](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318882189.png)</p>
<p>![1551318909264](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551318909264.png)</p>
<pre><code class="language-js">    &lt;div class=&quot;search&quot;&gt;
        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 获取要操作的元素
        var con = document.querySelector('.con');
        var jd_input = document.querySelector('.jd');
		// 给输入框注册keyup事件
        jd_input.addEventListener('keyup', function() {
				// 判断输入框内容是否为空
                if (this.value == '') {
                    // 为空，隐藏放大提示盒子
                    con.style.display = 'none';
                } else {
                    // 不为空，显示放大提示盒子，设置盒子的内容
                    con.style.display = 'block';
                    con.innerText = this.value;
                }
            })
        // 给输入框注册失去焦点事件，隐藏放大提示盒子
        jd_input.addEventListener('blur', function() {
                con.style.display = 'none';
            })
        // 给输入框注册获得焦点事件
        jd_input.addEventListener('focus', function() {
            // 判断输入框内容是否为空
            if (this.value !== '') {
                // 不为空则显示提示盒子
                con.style.display = 'block';
            }
        })
    &lt;/script&gt;
</code></pre>
<h2 id="12-bom">1.2. BOM</h2>
<h3 id="121-什么是bom">1.2.1. 什么是BOM</h3>
<p>​	BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p>
<p>​	BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p>
<p>​	BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</p>
<p>![1551319264407](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319264407.png)</p>
<h3 id="122-bom的构成">1.2.2. BOM的构成</h3>
<p>BOM 比 DOM 更大，它包含 DOM。</p>
<p>![1551319344183](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319344183.png)</p>
<h3 id="123-顶级对象window">1.2.3. 顶级对象window</h3>
<p>![1551319372909](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319372909.png)</p>
<h3 id="124-window对象的常见事件">1.2.4. window对象的常见事件</h3>
<h4 id="页面窗口加载事件2种">页面（窗口）加载事件（2种）</h4>
<p><strong>第1种</strong></p>
<p>![1551319525109](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319525109.png)</p>
<p>window.onload 是窗口 (页面）加载事件，<strong>当文档内容完全加载完成</strong>会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p>
<p>![1551319600263](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319600263.png)</p>
<p><strong>第2种</strong></p>
<p>![1551319620299](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319620299.png)</p>
<p>​	DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p>
<p>​	IE9以上才支持！！！</p>
<p>​	如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p>
<pre><code class="language-js">    &lt;script&gt;
        window.addEventListener('load', function() {
            var btn = document.querySelector('button');
            btn.addEventListener('click', function() {
                alert('点击我');
            })
        })
        window.addEventListener('load', function() {
            alert(22);
        })
        document.addEventListener('DOMContentLoaded', function() {
            alert(33);
        })
    &lt;/script&gt;
</code></pre>
<h4 id="调整窗口大小事件">调整窗口大小事件</h4>
<p>![1551319803117](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551319803117.png)</p>
<p>​	window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。</p>
<p>注意：</p>
<ol>
<li>
<p>只要窗口大小发生像素变化，就会触发这个事件。</p>
</li>
<li>
<p>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</p>
</li>
</ol>
<pre><code class="language-js">    &lt;script&gt;
        // 注册页面加载事件
        window.addEventListener('load', function() {
            var div = document.querySelector('div');
        	// 注册调整窗口大小事件
            window.addEventListener('resize', function() {
                // window.innerWidth 获取窗口大小
                console.log('变化了');
                if (window.innerWidth &lt;= 800) {
                    div.style.display = 'none';
                } else {
                    div.style.display = 'block';
                }
            })
        })
    &lt;/script&gt;
    &lt;div&gt;&lt;/div&gt;
</code></pre>
<h3 id="125-定时器两种">1.2.5. 定时器（两种）</h3>
<p>window 对象给我们提供了 2 个非常好用的方法-定时器。</p>
<ul>
<li>
<p>setTimeout()</p>
</li>
<li>
<p>setInterval()</p>
</li>
</ul>
<h4 id="settimeout-炸弹定时器">setTimeout() 炸弹定时器</h4>
<h5 id="开启定时器">开启定时器</h5>
<p>![1551320279307](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551320279307.png)</p>
<p>![1551320408854](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551320408854.png)</p>
<p>![1551320298981](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551320298981.png)</p>
<blockquote>
<pre><code>普通函数是按照代码顺序直接调用。

简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。
例如：定时器中的调用函数，事件处理函数，也是回调函数。

以前我们讲的   element.onclick = function(){}   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。

</code></pre>
</blockquote>
<pre><code class="language-js">    &lt;script&gt;
        // 回调函数是一个匿名函数
         setTimeout(function() {
             console.log('时间到了');

         }, 2000);
        function callback() {
            console.log('爆炸了');
        }
		// 回调函数是一个有名函数
        var timer1 = setTimeout(callback, 3000);
        var timer2 = setTimeout(callback, 5000);
    &lt;/script&gt;
</code></pre>
<h5 id="案例5秒后关闭广告">案例：5秒后关闭广告</h5>
<p>![1551320924828](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551320924828.png)</p>
<p>![1551320959756](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551320959756.png)</p>
<pre><code class="language-js">&lt;body&gt;
    &lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot;&gt;
    &lt;script&gt;
        // 获取要操作的元素
        var ad = document.querySelector('.ad');
		// 开启定时器
        setTimeout(function() {
            ad.style.display = 'none';
        }, 5000);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h5 id="停止定时器">停止定时器</h5>
<p>![1551321051001](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321051001.png)</p>
<p>![1551321064154](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321064154.png)</p>
<pre><code class="language-js">    &lt;button&gt;点击停止定时器&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
		// 开启定时器
        var timer = setTimeout(function() {
            console.log('爆炸了');
        }, 5000);
		// 给按钮注册单击事件
        btn.addEventListener('click', function() {
            // 停止定时器
            clearTimeout(timer);
        })
    &lt;/script&gt;
</code></pre>
<h4 id="setinterval-闹钟定时器">setInterval() 闹钟定时器</h4>
<h5 id="开启定时器-2">开启定时器</h5>
<p>![1551321162158](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321162158.png)</p>
<pre><code class="language-js">    &lt;script&gt;
        // 1. setInterval 
        setInterval(function() {
            console.log('继续输出');
        }, 1000);
    &lt;/script&gt;
</code></pre>
<h5 id="案例倒计时">案例：倒计时</h5>
<p>![1551321298787](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321298787.png)</p>
<p>![1551321322188](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321322188.png)</p>
<pre><code class="language-js">    &lt;div&gt;
        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素（时分秒盒子） 
        var hour = document.querySelector('.hour'); // 小时的黑色盒子
        var minute = document.querySelector('.minute'); // 分钟的黑色盒子
        var second = document.querySelector('.second'); // 秒数的黑色盒子
        var inputTime = +new Date('2019-5-1 18:00:00'); // 返回的是用户输入时间总的毫秒数

        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 

        // 2. 开启定时器
        setInterval(countDown, 1000);
		
        function countDown() {
            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 
            var h = parseInt(times / 60 / 60 % 24); //时
            h = h &lt; 10 ? '0' + h : h;
            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子
            var m = parseInt(times / 60 % 60); // 分
            m = m &lt; 10 ? '0' + m : m;
            minute.innerHTML = m;
            var s = parseInt(times % 60); // 当前的秒
            s = s &lt; 10 ? '0' + s : s;
            second.innerHTML = s;
        }
    &lt;/script&gt;
</code></pre>
<h5 id="停止定时器-2">停止定时器</h5>
<p>![1551321444559](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321444559.png)</p>
<h4 id="案例发送短信倒计时">案例：发送短信倒计时</h4>
<p>​	点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。</p>
<p>![1551321540676](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321540676.png)</p>
<p>![1551321564247](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551321564247.png)</p>
<pre><code class="language-js">    手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
		// 全局变量，定义剩下的秒数
        var time = 3; 
		// 注册单击事件
        btn.addEventListener('click', function() {
            // 禁用按钮
            btn.disabled = true;
            // 开启定时器
            var timer = setInterval(function() {
                // 判断剩余秒数
                if (time == 0) {
                    // 清除定时器和复原按钮
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.innerHTML = '发送';
                } else {
                    btn.innerHTML = '还剩下' + time + '秒';
                    time--;
                }
            }, 1000);
        });
    &lt;/script&gt;
</code></pre>
<h3 id="126-this指向问题">1.2.6. this指向问题</h3>
<p>​	this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</p>
<p>现阶段，我们先了解一下几个this指向</p>
<ol>
<li>
<p>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</p>
</li>
<li>
<p>方法调用中谁调用this指向谁</p>
</li>
<li>
<p>构造函数中this指向构造函数的实例</p>
</li>
</ol>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;script&gt;
        // this 指向问题 一般情况下this的最终指向的是那个调用它的对象
        // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）
        console.log(this);
        function fn() {
            console.log(this);
        }
        window.fn();
        window.setTimeout(function() {
            console.log(this);
        }, 1000);
        // 2. 方法调用中谁调用this指向谁
        var o = {
            sayHi: function() {
                console.log(this); // this指向的是 o 这个对象
            }
        }
        o.sayHi();
        var btn = document.querySelector('button');
        btn.addEventListener('click', function() {
                console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象
            })
        // 3. 构造函数中this指向构造函数的实例
        function Fun() {
            console.log(this); // this 指向的是fun 实例对象
        }
        var fun = new Fun();
    &lt;/script&gt;
</code></pre>
<h3 id="127-location对象">1.2.7. location对象</h3>
<h4 id="什么是-location-对象">什么是 location 对象</h4>
<p>![1551322091638](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322091638.png)</p>
<h4 id="url">URL</h4>
<p>![1551322373704](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322373704.png)</p>
<p>![1551322387201](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322387201.png)</p>
<h4 id="location-对象的属性">location 对象的属性</h4>
<p>![1551322416716](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322416716.png)</p>
<p>![1551322438200](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322438200.png)</p>
<h4 id="案例5分钟自动跳转页面">案例：5分钟自动跳转页面</h4>
<p>![1551322496871](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322496871.png)</p>
<p>![1551322517605](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322517605.png)</p>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        btn.addEventListener('click', function() {
            // console.log(location.href);
            location.href = 'http://www.itcast.cn';
        })
        var timer = 5;
        setInterval(function() {
            if (timer == 0) {
                location.href = 'http://www.itcast.cn';
            } else {
                div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页';
                timer--;
            }
        }, 1000);
    &lt;/script&gt;
</code></pre>
<h4 id="案例获取url参数">案例：获取URL参数</h4>
<p>![1551322622640](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322622640.png)</p>
<p>![1551322639241](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322639241.png)</p>
<pre><code class="language-js">    &lt;div&gt;&lt;/div&gt;
	&lt;script&gt;
        console.log(location.search); // ?uname=andy
        // 1.先去掉？  substr('起始的位置'，截取几个字符);
        var params = location.search.substr(1); // uname=andy
        console.log(params);
        // 2. 利用=把字符串分割为数组 split('=');
        var arr = params.split('=');
        console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;]
        var div = document.querySelector('div');
        // 3.把数据写入div中
        div.innerHTML = arr[1] + '欢迎您';
    &lt;/script&gt;
</code></pre>
<h4 id="location对象的常见方法">location对象的常见方法</h4>
<p>![1551322750241](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322750241.png)</p>
<pre><code class="language-js">    &lt;button&gt;点击&lt;/button&gt;
    &lt;script&gt;
        var btn = document.querySelector('button');
        btn.addEventListener('click', function() {
            // 记录浏览历史，所以可以实现后退功能
            // location.assign('http://www.itcast.cn');
            // 不记录浏览历史，所以不可以实现后退功能
            // location.replace('http://www.itcast.cn');
            location.reload(true);
        })
    &lt;/script&gt;
</code></pre>
<h3 id="128-navigator对象">1.2.8. navigator对象</h3>
<p>​	navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p>
<p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p>
<pre><code class="language-js">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    window.location.href = &quot;&quot;;     //手机
 } else {
    window.location.href = &quot;&quot;;     //电脑
 }
</code></pre>
<h3 id="129-history对象">1.2.9 history对象</h3>
<p>​	window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p>
<p>![1551322885216](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322885216.png)</p>
<p>history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</p>
<p>![1551322959148](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551322959148.png)</p>
<h2 id="13-js执行机制">1.3. JS执行机制</h2>
<p>以下代码执行的结果是什么？</p>
<pre><code class="language-js"> console.log(1);
 
 setTimeout(function () {
     console.log(3);
 }, 1000);
 
 console.log(2);
</code></pre>
<p>以下代码执行的结果是什么？</p>
<pre><code class="language-js"> console.log(1);
 
 setTimeout(function () {
     console.log(3);
 }, 0);
 
 console.log(2);
</code></pre>
<h3 id="131-js-是单线程">1.3.1 JS 是单线程</h3>
<p>![1551415019322](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551415019322.png)</p>
<pre><code class="language-js">	单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
	这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
</code></pre>
<h3 id="132-同步任务和异步任务">1.3.2 同步任务和异步任务</h3>
<p>​	单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</p>
<p>​	为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了<strong>同步任务</strong>和<strong>异步任务</strong>。</p>
<h4 id="同步">同步</h4>
<p>​	前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。</p>
<h4 id="异步">异步</h4>
<p>​	你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。</p>
<p>![1551434295074](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551434295074.png)</p>
<blockquote>
<pre><code class="language-js">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。

同步任务指的是：
	在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
异步任务指的是：
	不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。
</code></pre>
</blockquote>
<p>![1551434972778](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551434972778.png)</p>
<h3 id="133-js执行机制事件循环">1.3.3 JS执行机制（事件循环）</h3>
<p>![1551435335464](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551435335464.png)</p>
<p>![1551435398306](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551435398306.png)</p>
<p>![1551435449634](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day04/4-笔记/images/1551435449634.png)</p>
<h3 id="134-代码思考题">1.3.4 代码思考题</h3>
<pre><code class="language-js"> console.log(1);
 document.onclick = function() {
   console.log('click');
 }

 setTimeout(function() {
   console.log(3)
 }, 3000)
 console.log(2);
</code></pre>
<h1 id="day05-web-apis"><strong>day05 - Web APIs</strong></h1>
<blockquote>
<p><strong>学习目标:</strong></p>
<p>能够说出常见 offset 系列属性的作用</p>
<p>能够说出常见 client 系列属性的作用</p>
<p>能够说出常见 scroll 系列属性的作用</p>
<p>能够封装简单动画函数</p>
</blockquote>
<h2 id="11-元素偏移量-offset-系列">**1.1. **元素偏移量 offset 系列</h2>
<h3 id="111-offset-概述">1.1.1 offset 概述</h3>
<p>offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p>
<ol>
<li>
<p>获得元素距离带有定位父元素的位置</p>
</li>
<li>
<p>获得元素自身的大小（宽度高度）</p>
</li>
<li>
<p>注意：返回的数值都不带单位</p>
<p>![图片1](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/图片1.png)</p>
</li>
</ol>
<p>![图片2](F:\前端\【27】源码+课件+软件\07-10 JavaScript网页编程\02-WebAPI编程资料\Web APIs-day05\4-笔记\images\图片2.png)</p>
<h3 id="112-offset-与-style-区别">1.1.2 offset 与 style 区别</h3>
<h4 id="offset">offset</h4>
<ul>
<li>
<p>offset 可以得到任意样式表中的样式值</p>
</li>
<li>
<p>offset 系列获得的数值是没有单位的</p>
</li>
<li>
<p>offsetWidth 包含padding+border+width</p>
</li>
<li>
<p>offsetWidth 等属性是只读属性，只能获取不能赋值</p>
</li>
<li>
<blockquote>
<p>所以，我们想要获取元素大小位置，用offset更合适</p>
</blockquote>
</li>
</ul>
<h4 id="style">style</h4>
<ul>
<li>
<p>style 只能得到行内样式表中的样式值</p>
</li>
<li>
<p>style.width 获得的是带有单位的字符串</p>
</li>
<li>
<p>style.width 获得不包含padding和border 的值</p>
</li>
<li>
<p>style.width 是可读写属性，可以获取也可以赋值</p>
</li>
<li>
<blockquote>
<p>所以，我们想要给元素更改值，则需要用style改变</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p>
</blockquote>
<h3 id="113-案例获取鼠标在盒子内的坐标">1.1.3  案例：获取鼠标在盒子内的坐标</h3>
<ol>
<li>我们在盒子内点击，想要得到鼠标距离盒子左右的距离。</li>
<li>首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</li>
<li>其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop)</li>
<li>用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标</li>
<li>如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动</li>
</ol>
<pre><code class="language-javascript">var box = document.querySelector('.box');
box.addEventListener('mousemove', function(e) {
var x = e.pageX - this.offsetLeft;
var y = e.pageY - this.offsetTop;
this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
})
</code></pre>
<h3 id="114-案例模态框拖拽">1.1.4  案例：模态框拖拽</h3>
<p>弹出框，我们也称为模态框。</p>
<p>​	1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。</p>
<p>​	2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。</p>
<p>​	3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。</p>
<p>​	4.鼠标松开，可以停止拖动模态框移动</p>
<h3 id="115-案例分析">1.1.5. 案例分析:</h3>
<ol>
<li>点击弹出层， 模态框和遮挡层就会显示出来 display:block;</li>
<li>点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;</li>
<li>在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标</li>
<li>触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup</li>
<li>拖拽过程:  鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了</li>
<li>鼠标按下触发的事件源是最上面一行，就是  id 为 title</li>
<li>鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。</li>
<li>鼠标按下，我们要得到鼠标在盒子的坐标。</li>
<li>鼠标移动，就让模态框的坐标  设置为  ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。</li>
<li>鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除</li>
</ol>
<pre><code class="language-javascript"> // 1. 获取元素
        var login = document.querySelector('.login');
        var mask = document.querySelector('.login-bg');
        var link = document.querySelector('#link');
        var closeBtn = document.querySelector('#closeBtn');
        var title = document.querySelector('#title');
        // 2. 点击弹出层这个链接 link  让mask 和login 显示出来
        link.addEventListener('click', function() {
                mask.style.display = 'block';
                login.style.display = 'block';
            })
            // 3. 点击 closeBtn 就隐藏 mask 和 login 
        closeBtn.addEventListener('click', function() {
                mask.style.display = 'none';
                login.style.display = 'none';
            })
            // 4. 开始拖拽
            // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标
        title.addEventListener('mousedown', function(e) {
            var x = e.pageX - login.offsetLeft;
            var y = e.pageY - login.offsetTop;
            // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值
            document.addEventListener('mousemove', move)

            function move(e) {
                login.style.left = e.pageX - x + 'px';
                login.style.top = e.pageY - y + 'px';
            }
            // (3) 鼠标弹起，就让鼠标移动事件移除
            document.addEventListener('mouseup', function() {
                document.removeEventListener('mousemove', move);
            })
        })

</code></pre>
<h3 id="116-案例仿京东放大镜">1.1.6  案例：仿京东放大镜</h3>
<ol>
<li>整个案例可以分为三个功能模块</li>
<li>鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能</li>
<li>黄色的遮挡层跟随鼠标功能。</li>
<li>移动黄色遮挡层，大图片跟随移动功能。</li>
</ol>
<h3 id="117-案例分析">1.1.7. 案例分析:</h3>
<ol>
<li>黄色的遮挡层跟随鼠标功能。</li>
<li>把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。</li>
<li>首先是获得鼠标在盒子的坐标。</li>
<li>之后把数值给遮挡层做为left 和top值。</li>
<li>此时用到鼠标移动事件，但是还是在小图片盒子内移动。</li>
<li>发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。</li>
<li>遮挡层不能超出小图片盒子范围。</li>
<li>如果小于零，就把坐标设置为0</li>
<li>如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离</li>
<li>遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</li>
</ol>
<figure data-type="image" tabindex="28"><img src="images%5C1551881487(1).png" alt="1551881487(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/1551881487(1).png)" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="images%5C1551881563(1).jpg" alt="1551881563(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/1551881563(1).jpg)" loading="lazy"></figure>
<pre><code class="language-javascript">window.addEventListener('load', function() {
    var preview_img = document.querySelector('.preview_img');
    var mask = document.querySelector('.mask');
    var big = document.querySelector('.big');
    // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子
    preview_img.addEventListener('mouseover', function() {
        mask.style.display = 'block';
        big.style.display = 'block';
    })
    preview_img.addEventListener('mouseout', function() {
            mask.style.display = 'none';
            big.style.display = 'none';
        })
        // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走
    preview_img.addEventListener('mousemove', function(e) {
        // (1). 先计算出鼠标在盒子内的坐标
        var x = e.pageX - this.offsetLeft;
        var y = e.pageY - this.offsetTop;
        // console.log(x, y);
        // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了
        // (3) 我们mask 移动的距离
        var maskX = x - mask.offsetWidth / 2;
        var maskY = y - mask.offsetHeight / 2;
        // (4) 如果x 坐标小于了0 就让他停在0 的位置
        // 遮挡层的最大移动距离
        var maskMax = preview_img.offsetWidth - mask.offsetWidth;
        if (maskX &lt;= 0) {
            maskX = 0;
        } else if (maskX &gt;= maskMax) {
            maskX = maskMax;
        }
        if (maskY &lt;= 0) {
            maskY = 0;
        } else if (maskY &gt;= maskMax) {
            maskY = maskMax;
        }
        mask.style.left = maskX + 'px';
        mask.style.top = maskY + 'px';
        // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
        // 大图
        var bigIMg = document.querySelector('.bigImg');
        // 大图片最大移动距离
        var bigMax = bigIMg.offsetWidth - big.offsetWidth;
        // 大图片的移动距离 X Y
        var bigX = maskX * bigMax / maskMax;
        var bigY = maskY * bigMax / maskMax;
        bigIMg.style.left = -bigX + 'px';
        bigIMg.style.top = -bigY + 'px';

    })

})
</code></pre>
<h2 id="12-元素可视区-client-系列">1.2. 元素可视区 client 系列</h2>
<h3 id="121-client概述">1.2.1 client概述</h3>
<p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client<br>
系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</p>
<p>![图片3](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/图片3.png)</p>
<p>![图片4](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/图片4.png)</p>
<h3 id="122-淘宝-flexiblejs-源码分析">1.2.2. 淘宝 flexible.js 源码分析</h3>
<p>立即执行函数 (function(){})()  或者 (function(){}())</p>
<p>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</p>
<p>下面三种情况都会刷新页面都会触发 load 事件。</p>
<p>1.a标签的超链接</p>
<p>2.F5或者刷新按钮（强制刷新）</p>
<p>3.前进后退按钮</p>
<p>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。</p>
<p>所以此时后退按钮不能刷新页面。</p>
<p>此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件</p>
<p><code>注意这个事件给window添加。</code></p>
<h2 id="13元素滚动-scroll-系列">1.3.元素滚动 scroll 系列</h2>
<h3 id="131-scroll-概述">1.3.1. scroll 概述</h3>
<p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<p>![图片5](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/图片5.png)</p>
<p>![图片6](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/图片6.png)</p>
<h3 id="132-页面被卷去的头部">1.3.2. 页面被卷去的头部</h3>
<p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。</p>
<h3 id="133案例仿淘宝固定右侧侧边栏">1.3.3.案例：仿淘宝固定右侧侧边栏</h3>
<ol>
<li>原先侧边栏是绝对定位</li>
<li>当页面滚动到一定位置，侧边栏改为固定定位</li>
<li>页面继续滚动，会让 返回顶部显示出来</li>
</ol>
<h3 id="134案例分析">1.3.4.案例分析:</h3>
<ol>
<li>需要用到页面滚动事件 scroll  因为是页面滚动，所以事件源是document</li>
<li>滚动到某个位置，就是判断页面被卷去的上部值。</li>
<li>页面被卷去的头部：可以通过window.pageYOffset 获得  如果是被卷去的左侧window.pageXOffset</li>
<li>注意，元素被卷去的头部是element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset</li>
<li>其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了</li>
</ol>
<pre><code class="language-javascript">  //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
            // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
            // console.log(11);
            // window.pageYOffset 页面被卷去的头部
            // console.log(window.pageYOffset);
            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
            if (window.pageYOffset &gt;= bannerTop) {
                sliderbar.style.position = 'fixed';
                sliderbar.style.top = sliderbarTop + 'px';
            } else {
                sliderbar.style.position = 'absolute';
                sliderbar.style.top = '300px';
            }
            // 4. 当我们页面滚动到main盒子，就显示 goback模块
            if (window.pageYOffset &gt;= mainTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';
            }

        })
</code></pre>
<h3 id="135页面被卷去的头部兼容性解决方案">1.3.5.页面被卷去的头部兼容性解决方案</h3>
<p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</p>
<ol>
<li>声明了 DTD，使用 document.documentElement.scrollTop</li>
<li>未声明 DTD，使用  document.body.scrollTop</li>
<li>新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</li>
</ol>
<pre><code class="language-javascript">function getScroll() {
    return {
      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    };
 } 
使用的时候  getScroll().left

</code></pre>
<h2 id="14-三大系列总结">1.4. 三大系列总结</h2>
<p>![图片7](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day05/4-笔记/images/图片7.png)</p>
<p>他们主要用法：</p>
<p>1.offset系列 经常用于获得元素位置    offsetLeft  offsetTop</p>
<p>2.client经常用于获取元素大小  clientWidth clientHeight</p>
<p>3.scroll 经常用于获取滚动距离 scrollTop  scrollLeft</p>
<p>4.注意页面滚动的距离通过 window.pageXOffset  获得</p>
<h2 id="15-mouseenter-和mouseover的区别">1.5. mouseenter 和mouseover的区别</h2>
<ul>
<li>当鼠标移动到元素上时就会触发mouseenter 事件</li>
<li>类似 mouseover，它们两者之间的差别是</li>
<li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</li>
<li>之所以这样，就是因为mouseenter不会冒泡</li>
<li>跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</li>
</ul>
<h2 id="16-动画函数封装">1.6. 动画函数封装</h2>
<h3 id="161-动画实现原理">1.6.1. 动画实现原理</h3>
<blockquote>
<p>核心原理：通过定时器 setInterval() 不断移动盒子位置。</p>
</blockquote>
<p>实现步骤：</p>
<ol>
<li>获得盒子当前位置</li>
<li>让盒子在当前位置加上1个移动距离</li>
<li>利用定时器不断重复这个操作</li>
<li>加一个结束定时器的条件</li>
<li>注意此元素需要添加定位，才能使用element.style.left</li>
</ol>
<h3 id="162-动画函数给不同元素记录不同定时器">1.6.2. 动画函数给不同元素记录不同定时器</h3>
<p>如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</p>
<blockquote>
<p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p>
</blockquote>
<pre><code class="language-javascript"> function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function() {
                if (obj.offsetLeft &gt;= target) {
                    // 停止动画 本质是停止定时器
                    clearInterval(obj.timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';

            }, 30);
        }

</code></pre>
<h1 id="day06-web-apis"><strong>day06 - Web APIs</strong></h1>
<blockquote>
<p><strong>学习目标:</strong></p>
<p>能够封装简单动画函数</p>
<p>能够理解缓动动画的封装</p>
<p>能够使用动画函数</p>
<p>能够写出网页轮播图案例</p>
<p>能够写出移动端触屏事件</p>
</blockquote>
<h2 id="11-动画函数封装">**1.1. **动画函数封装</h2>
<h3 id="111-缓动效果原理">1.1.1 缓动效果原理</h3>
<p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p>
<p>思路：</p>
<ol>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li>
<li>核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长</li>
<li>停止的条件是： 让当前盒子位置等于目标位置就停止定时器</li>
<li>注意步长值需要取整</li>
</ol>
<h3 id="112-动画函数多个目标值之间移动">1.1.2 动画函数多个目标值之间移动</h3>
<p>可以让动画函数从 800 移动到 500。</p>
<p>当我们点击按钮时候，判断步长是正值还是负值</p>
<p>​	1.如果是正值，则步长往大了取整</p>
<p>​	2.如果是负值，则步长 向小了取整</p>
<h3 id="113-动函数添加回调函数">1.1.3  动函数添加回调函数</h3>
<p>回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p>
<p>回调函数写的位置：定时器结束的位置。</p>
<h3 id="114-动画完整版代码">1.1.4  动画完整版代码:</h3>
<pre><code class="language-javascript">function animate(obj, target, callback) {
    // console.log(callback);  callback = function() {}  调用的时候 callback()

    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInterval(function() {
        // 步长值写到定时器的里面
        // 把我们步长值改为整数 不要出现小数的问题
        // var step = Math.ceil((target - obj.offsetLeft) / 10);
        var step = (target - obj.offsetLeft) / 10;
        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
        if (obj.offsetLeft == target) {
            // 停止动画 本质是停止定时器
            clearInterval(obj.timer);
            // 回调函数写到定时器结束里面
            // if (callback) {
            //     // 调用函数
            //     callback();
            // }
            callback &amp;&amp; callback();
        }
        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
        obj.style.left = obj.offsetLeft + step + 'px';

    }, 15);
}
</code></pre>
<h2 id="12-常见网页特效案例">1.2. 常见网页特效案例</h2>
<h3 id="121-案例网页轮播图">1.2.1 案例：网页轮播图</h3>
<p>轮播图也称为焦点图，是网页中比较常见的网页特效。</p>
<p>功能需求：</p>
<p>​	1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</p>
<p>​	2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</p>
<p>​	3.图片播放的同时，下面小圆圈模块跟随一起变化。</p>
<p>​	4.点击小圆圈，可以播放相应图片。</p>
<p>​	5.鼠标不经过轮播图，轮播图也会自动播放图片。</p>
<p>​	6.鼠标经过，轮播图模块， 自动播放停止。</p>
<pre><code>window.addEventListener('load', function() {
    // 1. 获取元素
    var arrow_l = document.querySelector('.arrow-l');
    var arrow_r = document.querySelector('.arrow-r');
    var focus = document.querySelector('.focus');
    var focusWidth = focus.offsetWidth;
    // 2. 鼠标经过focus 就显示隐藏左右按钮
    focus.addEventListener('mouseenter', function() {
        arrow_l.style.display = 'block';
        arrow_r.style.display = 'block';
        clearInterval(timer);
        timer = null; // 清除定时器变量
    });
    focus.addEventListener('mouseleave', function() {
        arrow_l.style.display = 'none';
        arrow_r.style.display = 'none';
        timer = setInterval(function() {
            //手动调用点击事件
            arrow_r.click();
        }, 2000);
    });
    // 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈
    var ul = focus.querySelector('ul');
    var ol = focus.querySelector('.circle');
    // console.log(ul.children.length);
    for (var i = 0; i &lt; ul.children.length; i++) {
        // 创建一个小li 
        var li = document.createElement('li');
        // 记录当前小圆圈的索引号 通过自定义属性来做 
        li.setAttribute('index', i);
        // 把小li插入到ol 里面
        ol.appendChild(li);
        // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件
        li.addEventListener('click', function() {
            // 干掉所有人 把所有的小li 清除 current 类名
            for (var i = 0; i &lt; ol.children.length; i++) {
                ol.children[i].className = '';
            }
            // 留下我自己  当前的小li 设置current 类名
            this.className = 'current';
            // 5. 点击小圆圈，移动图片 当然移动的是 ul 
            // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值
            // 当我们点击了某个小li 就拿到当前小li 的索引号
            var index = this.getAttribute('index');
            // 当我们点击了某个小li 就要把这个li 的索引号给 num  
            num = index;
            // 当我们点击了某个小li 就要把这个li 的索引号给 circle  
            circle = index;
            // num = circle = index;
            console.log(focusWidth);
            console.log(index);

            animate(ul, -index * focusWidth);
        })
    }
    // 把ol里面的第一个小li设置类名为 current
    ol.children[0].className = 'current';
    // 6. 克隆第一张图片(li)放到ul 最后面
    var first = ul.children[0].cloneNode(true);
    ul.appendChild(first);
    // 7. 点击右侧按钮， 图片滚动一张
    var num = 0;
    // circle 控制小圆圈的播放
    var circle = 0;
    // flag 节流阀
    var flag = true;
    arrow_r.addEventListener('click', function() {
        if (flag) {
            flag = false; // 关闭节流阀
            // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0
            if (num == ul.children.length - 1) {
                ul.style.left = 0;
                num = 0;
            }
            num++;
            animate(ul, -num * focusWidth, function() {
                flag = true; // 打开节流阀
            });
            // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
            circle++;
            // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原
            if (circle == ol.children.length) {
                circle = 0;
            }
            // 调用函数
            circleChange();
        }
    });

    // 9. 左侧按钮做法
    arrow_l.addEventListener('click', function() {
        if (flag) {
            flag = false;
            if (num == 0) {
                num = ul.children.length - 1;
                ul.style.left = -num * focusWidth + 'px';

            }
            num--;
            animate(ul, -num * focusWidth, function() {
                flag = true;
            });
            // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
            circle--;
            // 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）
            // if (circle &lt; 0) {
            //     circle = ol.children.length - 1;
            // }
            circle = circle &lt; 0 ? ol.children.length - 1 : circle;
            // 调用函数
            circleChange();
        }
    });

    function circleChange() {
        // 先清除其余小圆圈的current类名
        for (var i = 0; i &lt; ol.children.length; i++) {
            ol.children[i].className = '';
        }
        // 留下当前的小圆圈的current类名
        ol.children[circle].className = 'current';
    }
    // 10. 自动播放轮播图
    var timer = setInterval(function() {
        //手动调用点击事件
        arrow_r.click();
    }, 2000);

})
</code></pre>
<h3 id="122-节流阀">1.2.2. 节流阀</h3>
<p>防止轮播图按钮连续点击造成播放过快。</p>
<p>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p>
<p>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p>
<p>开始设置一个变量var flag= true;</p>
<p>If(flag){flag = false; do something}       关闭水龙头</p>
<p>利用回调函数动画执行完毕， flag = true     打开水龙头</p>
<h3 id="123-案例返回顶部">1.2.3. 案例：返回顶部</h3>
<ol>
<li>带有动画的返回顶部</li>
<li>此时可以继续使用我们封装的动画函数</li>
<li>只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了</li>
<li>页面滚动了多少，可以通过 window.pageYOffset 得到</li>
<li>最后是页面滚动，使用 window.scroll(x,y)</li>
</ol>
<pre><code class="language-javascript">  //1. 获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');
        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop
            // 当我们侧边栏固定定位之后应该变化的数值
        var sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        var mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener('scroll', function() {
                // console.log(11);
                // window.pageYOffset 页面被卷去的头部
                // console.log(window.pageYOffset);
                // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位
                if (window.pageYOffset &gt;= bannerTop) {
                    sliderbar.style.position = 'fixed';
                    sliderbar.style.top = sliderbarTop + 'px';
                } else {
                    sliderbar.style.position = 'absolute';
                    sliderbar.style.top = '300px';
                }
                // 4. 当我们页面滚动到main盒子，就显示 goback模块
                if (window.pageYOffset &gt;= mainTop) {
                    goBack.style.display = 'block';
                } else {
                    goBack.style.display = 'none';
                }

            })
            // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方
        goBack.addEventListener('click', function() {
            // 里面的x和y 不跟单位的 直接写数字即可
            // window.scroll(0, 0);
            // 因为是窗口滚动 所以对象是window
            animate(window, 0);
        });

</code></pre>
<h3 id="124-案例筋头云案例">1.2.4. 案例：筋头云案例</h3>
<ol>
<li>利用动画函数做动画效果</li>
<li>原先筋斗云的起始位置是0</li>
<li>鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可</li>
<li>鼠标离开某个小li，就把目标值设为 0</li>
<li>如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置</li>
</ol>
<pre><code class="language-javascript"> window.addEventListener('load', function() {
            // 1. 获取元素
            var cloud = document.querySelector('.cloud');
            var c_nav = document.querySelector('.c-nav');
            var lis = c_nav.querySelectorAll('li');
            // 2. 给所有的小li绑定事件 
            // 这个current 做为筋斗云的起始位置
            var current = 0;
            for (var i = 0; i &lt; lis.length; i++) {
                // (1) 鼠标经过把当前小li 的位置做为目标值
                lis[i].addEventListener('mouseenter', function() {
                    animate(cloud, this.offsetLeft);
                });
                // (2) 鼠标离开就回到起始的位置 
                lis[i].addEventListener('mouseleave', function() {
                    animate(cloud, current);
                });
                // (3) 当我们鼠标点击，就把当前位置做为目标值
                lis[i].addEventListener('click', function() {
                    current = this.offsetLeft;
                });
            }
        })

</code></pre>
<h2 id="13-触屏事件">1.3. 触屏事件</h2>
<h3 id="131-触屏事件概述">1.3.1. 触屏事件概述</h3>
<p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。</p>
<p>touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。</p>
<p>常见的触屏事件如下：</p>
<p>![图片1](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day06/4-笔记/images/图片1.png)</p>
<h3 id="132-触摸事件对象touchevent">1.3.2. 触摸事件对象（TouchEvent）</h3>
<p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p>
<p>touchstart、touchmove、touchend 三个事件都会各自有事件对象。</p>
<p>触摸事件对象重点我们看三个常见对象列表：</p>
<p>![图片2](C:\Users\张建平\Desktop\Web APls笔记\images\图片2.png)</p>
<blockquote>
<p><code>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</code></p>
</blockquote>
<h3 id="133案例移动端拖动元素">1.3.3.案例：移动端拖动元素</h3>
<ol>
<li>
<p>touchstart、touchmove、touchend可以实现拖动元素</p>
</li>
<li>
<p>但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY</p>
</li>
<li>
<p>移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</p>
</li>
<li>
<p>手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置</p>
<p>拖动元素三步曲：</p>
<p>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</p>
<p>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</p>
<p>（3） 离开手指 touchend:</p>
<p><code>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</code></p>
</li>
</ol>
<h1 id="day07-web-apis"><strong>day07 - Web APIs</strong></h1>
<blockquote>
<p><strong>学习目标:</strong></p>
<p>能够写出移动端触屏事件<br>
能够写出常见的移动端特效<br>
能够使用移动端开发插件开发移动端特效<br>
能够使用移动端开发框架开发移动端特效<br>
能够写出 sessionStorage 数据的存储以及获取<br>
能够写出 localStorage 数据的存储以及获取<br>
能够说出它们两者的区别</p>
</blockquote>
<h2 id="11-触屏事件"><strong>1.1. 触屏事件</strong></h2>
<h3 id="111-触屏事件概述">1.1.1 触屏事件概述</h3>
<p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。</p>
<p>常见的触屏事件如下：</p>
<p>![图片1](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/图片1.png)</p>
<h3 id="112-触摸事件对象touchevent">1.1.2 触摸事件对象（TouchEvent）</h3>
<p>TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</p>
<p>touchstart、touchmove、touchend 三个事件都会各自有事件对象。</p>
<p>触摸事件对象重点我们看三个常见对象列表：</p>
<p>![图片2](F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/图片2.png)</p>
<blockquote>
<p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p>
</blockquote>
<h3 id="113-移动端拖动元素">1.1.3  移动端拖动元素</h3>
<ol>
<li>touchstart、touchmove、touchend 可以实现拖动元素</li>
<li>但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY</li>
<li>移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li>
<li>手指移动的距离：  手指滑动中的位置 减去  手指刚开始触摸的位置</li>
</ol>
<p>拖动元素三步曲：</p>
<p>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</p>
<p>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</p>
<p>（3） 离开手指 touchend:</p>
<blockquote>
<p><strong>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</strong></p>
</blockquote>
<h2 id="12-移动端常见特效">1.2. 移动端常见特效</h2>
<h3 id="121-案例-移动轮播图">1.2.1 案例: 移动轮播图</h3>
<p><code>移动端轮播图功能和基本PC端一致。</code></p>
<ol>
<li>可以自动播放图片</li>
<li>手指可以拖动播放轮播图</li>
</ol>
<h3 id="122-案例分析">1.2.2. 案例分析:</h3>
<ol>
<li>
<p>自动播放功能</p>
</li>
<li>
<p>开启定时器</p>
</li>
<li>
<p>移动端移动，可以使用translate 移动</p>
</li>
<li>
<p>想要图片优雅的移动，请添加过渡效果<img src="images%5C1551795152(1).jpg" alt="1551795152(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551795152(1).jpg)" loading="lazy"></p>
</li>
<li>
<p>自动播放功能-无缝滚动</p>
</li>
<li>
<p>注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断</p>
</li>
<li>
<p>此时需要添加检测过渡完成事件  transitionend</p>
</li>
<li>
<p>判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0</p>
</li>
<li>
<p>此时图片，去掉过渡效果，然后移动</p>
</li>
<li>
<p>如果索引号小于0， 说明是倒着走， 索引号等于2</p>
</li>
<li>
<p>此时图片，去掉过渡效果，然后移动</p>
<figure data-type="image" tabindex="30"><img src="images%5C1551795483(1).jpg" alt="1551795483(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551795483(1).jpg)" loading="lazy"></figure>
</li>
</ol>
<h2 id="123-classlist-属性">1.2.3 classList 属性</h2>
<p>classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。</p>
<p>该属性用于在元素中添加，移除及切换 CSS 类。有以下方法</p>
<p><strong>添加类：</strong></p>
<p>element.classList.add（’类名’）；</p>
<pre><code class="language-javascript">focus.classList.add('current');
</code></pre>
<p><strong>移除类：</strong></p>
<p>element.classList.remove（’类名’）;</p>
<pre><code class="language-javascript">focus.classList.remove('current');
</code></pre>
<p><strong>切换类：</strong></p>
<p>element.classList.toggle（’类名’）;</p>
<pre><code class="language-javascript">focus.classList.toggle('current');
</code></pre>
<p><code>注意:以上方法里面，所有类名都不带点</code></p>
<h3 id="124-案例分析">1.2.4. 案例分析</h3>
<ol>
<li>
<p>小圆点跟随变化效果</p>
</li>
<li>
<p>把ol里面li带有current类名的选出来去掉类名 remove</p>
</li>
<li>
<p>让当前索引号的小li 加上 current   add</p>
</li>
<li>
<p>但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面</p>
<figure data-type="image" tabindex="31"><img src="images%5C1551796072(1).jpg" alt="1551796072(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551796072(1).jpg)" loading="lazy"></figure>
</li>
<li>
<p>手指滑动轮播图</p>
</li>
<li>
<p>本质就是ul跟随手指移动，简单说就是移动端拖动元素</p>
</li>
<li>
<p>触摸元素touchstart：  获取手指初始坐标</p>
</li>
<li>
<p>移动手指touchmove：  计算手指的滑动距离，并且移动盒子</p>
</li>
<li>
<p>离开手指touchend:   根据滑动的距离分不同的情况</p>
</li>
<li>
<p>如果移动距离小于某个像素  就回弹原来位置</p>
</li>
<li>
<p>如果移动距离大于某个像素就上一张下一张滑动。</p>
</li>
<li>
<p>滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑</p>
</li>
<li>
<p>如果是左滑就播放下一张 （index++）</p>
</li>
<li>
<p>如果是右滑就播放上一张  (index--)</p>
</li>
</ol>
<figure data-type="image" tabindex="32"><img src="images%5C1551796363(1).jpg" alt="1551796363(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551796363(1).jpg)" loading="lazy"></figure>
<figure data-type="image" tabindex="33"><img src="images%5C1551796502(1).jpg" alt="1551796502(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551796502(1).jpg)" loading="lazy"></figure>
<h3 id="131-案例返回顶部">1.3.1. 案例：返回顶部</h3>
<p>当页面滚动某个地方，就显示，否则隐藏</p>
<p>点击可以返回顶部</p>
<h3 id="132案例分析">1.3.2.案例分析</h3>
<ol>
<li>滚动某个地方显示</li>
<li>事件：scroll页面滚动事件</li>
<li>如果被卷去的头部（window.pageYOffset ）大于某个数值</li>
<li>点击，window.scroll(0,0) 返回顶部</li>
</ol>
<figure data-type="image" tabindex="34"><img src="images%5C1551797003(1).jpg" alt="1551797003(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551797003(1).jpg)" loading="lazy"></figure>
<h2 id="14-click-延时解决方案">1.4. click 延时解决方案</h2>
<p>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。</p>
<p>解决方案：</p>
<p>​	1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。</p>
<pre><code class="language-html">  &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;
</code></pre>
<p>​	2.利用touch事件自己封装这个事件解决300ms 延迟。</p>
<p>​	原理就是：</p>
<ol>
<li>当我们手指触摸屏幕，记录当前触摸时间</li>
<li>当我们手指离开屏幕， 用离开的时间减去触摸的时间</li>
<li>如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击</li>
</ol>
<p>代码如下:</p>
<pre><code class="language-javascript">//封装tap，解决click 300ms 延时
function tap (obj, callback) {
        var isMove = false;
        var startTime = 0; // 记录触摸时候的时间变量
        obj.addEventListener('touchstart', function (e) {
            startTime = Date.now(); // 记录触摸时间
        });
        obj.addEventListener('touchmove', function (e) {
            isMove = true;  // 看看是否有滑动，有滑动算拖拽，不算点击
        });
        obj.addEventListener('touchend', function (e) {
            if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) {  // 如果手指触摸和离开时间小于150ms 算点击
                callback &amp;&amp; callback(); // 执行回调函数
            }
            isMove = false;  //  取反 重置
            startTime = 0;
        });
}
//调用  
  tap(div, function(){   // 执行代码  });

</code></pre>
<ol start="3">
<li>
<p>使用插件。fastclick 插件解决300ms 延迟。</p>
<figure data-type="image" tabindex="35"><img src="images%5C1551797533(1).jpg" alt="1551797533(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551797533(1).jpg)" loading="lazy"></figure>
</li>
</ol>
<h2 id="15-移动端常用开发插件">1.5. 移动端常用开发插件</h2>
<h3 id="151-什么是插件">1.5.1. 什么是插件</h3>
<p>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？</p>
<p>JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。</p>
<p>特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<p>我们以前写的animate.js 也算一个最简单的插件</p>
<p>fastclick 插件解决 300ms 延迟。 使用延时</p>
<p>GitHub官网地址： <a href="https://github.com/ftlabs/fastclick">https://</a><a href="https://github.com/ftlabs/fastclick">github.com/ftlabs/fastclick</a></p>
<h3 id="152-插件的使用">1.5.2. 插件的使用</h3>
<ol>
<li>
<p>引入 js 插件文件。</p>
</li>
<li>
<p>按照规定语法使用。</p>
</li>
<li>
<p>fastclick 插件解决 300ms 延迟。 使用延时</p>
</li>
<li>
<p>GitHub官网地址： https://github.com/ftlabs/fastclick</p>
<pre><code class="language-javascript">if ('addEventListener' in document) {
            document.addEventListener('DOMContentLoaded', function() {
                       FastClick.attach(document.body);
            }, false);
}
</code></pre>
</li>
</ol>
<h3 id="153-swiper-插件的使用">1.5.3. Swiper 插件的使用</h3>
<p>中文官网地址： https://www.swiper.com.cn/</p>
<ol>
<li>引入插件相关文件。</li>
<li>按照规定语法使用</li>
</ol>
<h3 id="154-其他移动端常见插件">1.5.4. 其他移动端常见插件</h3>
<p>lsuperslide： http://www.superslide2.com/</p>
<p>l iscroll： https://github.com/cubiq/iscroll</p>
<h3 id="155-插件的使用总结">1.5.5. 插件的使用总结</h3>
<p>1.确认插件实现的功能</p>
<p>2.去官网查看使用说明</p>
<p>3.下载插件</p>
<p>4.打开demo实例文件，查看需要引入的相关文件，并且引入</p>
<p>5.复制demo实例文件中的结构html，样式css以及js代码</p>
<h3 id="156-移动端视频插件-zymediajs">1.5.6. 移动端视频插件 zy.media.js</h3>
<p>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。</p>
<p>不同的视频格式文件，我们可以通过source解决。</p>
<p>但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。</p>
<p>这个时候我们可以使用插件方式来制作。</p>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<h2 id="16-移动端常用开发框架">1.6. 移动端常用开发框架</h2>
<h3 id="161-移动端视频插件-zymediajs">1.6.1. 移动端视频插件 zy.media.js</h3>
<p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p>
<p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<p>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端</p>
<p>前端常用的移动端插件有 swiper、superslide、iscroll等。</p>
<p>框架： 大而全，一整套解决方案</p>
<p>插件： 小而专一，某个功能的解决方案</p>
<h3 id="162-bootstrap">1.6.2. Bootstrap</h3>
<p>Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。</p>
<p>它能开发PC端，也能开发移动端</p>
<p>Bootstrap JS插件使用步骤：</p>
<p>1.引入相关js 文件</p>
<p>2.复制HTML 结构</p>
<p>3.修改对应样式</p>
<p>4.修改相应JS 参数</p>
<h2 id="17-本地存储">1.7. 本地存储</h2>
<p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p>
<h3 id="171本地存储特性">1.7.1.本地存储特性</h3>
<p>1、数据存储在用户浏览器中</p>
<p>2、设置、读取方便、甚至页面刷新不丢失数据</p>
<p>3、容量较大，sessionStorage约5M、localStorage约20M</p>
<p>4、只能存储字符串，可以将对象JSON.stringify() 编码后存储</p>
<h3 id="172windowsessionstorage">1.7.2.window.sessionStorage</h3>
<p>1、生命周期为关闭浏览器窗口</p>
<p>2、在同一个窗口(页面)下数据可以共享</p>
<p>3、以键值对的形式存储使用</p>
<p>存储数据：</p>
<pre><code class="language-javascript">sessionStorage.setItem(key, value)
</code></pre>
<p>获取数据：</p>
<pre><code class="language-javascript">sessionStorage.getItem(key)
</code></pre>
<p>删除数据：</p>
<pre><code class="language-javascript">sessionStorage.removeItem(key)
</code></pre>
<p>清空数据：(所有都清除掉)</p>
<pre><code class="language-javascript">sessionStorage.clear()
</code></pre>
<h3 id="173windowlocalstorage">1.7.3.window.localStorage</h3>
<p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3.  以键值对的形式存储使用</p>
<p>存储数据：</p>
<pre><code class="language-javascript">localStorage.setItem(key, value)
</code></pre>
<p>获取数据：</p>
<pre><code class="language-javascript">localStorage.getItem(key)
</code></pre>
<p>删除数据：</p>
<pre><code class="language-javascript">localStorage.removeItem(key)
</code></pre>
<p>清空数据：(所有都清除掉)</p>
<pre><code class="language-javascript">localStorage.clear()
</code></pre>
<h3 id="174案例记住用户名">1.7.4.案例：记住用户名</h3>
<p>如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名</p>
<h4 id="案例分析">案例分析</h4>
<ol>
<li>
<p>把数据存起来，用到本地存储</p>
</li>
<li>
<p>关闭页面，也可以显示用户名，所以用到localStorage</p>
</li>
<li>
<p>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框</p>
</li>
<li>
<p>当复选框发生改变的时候change事件</p>
</li>
<li>
<p>如果勾选，就存储，否则就移除</p>
<figure data-type="image" tabindex="36"><img src="images%5C1551800263(1).jpg" alt="1551800263(F:/前端/【27】源码+课件+软件/07-10 JavaScript网页编程/02-WebAPI编程资料/Web APIs-day07/4-笔记/images/1551800263(1).jpg)" loading="lazy"></figure>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Javacript基础选择题]]></title>
        <id>https://zjp693.github.io/post/javas-ji-chu-xuan-ze-ti/</id>
        <link href="https://zjp693.github.io/post/javas-ji-chu-xuan-ze-ti/">
        </link>
        <updated>2020-03-07T16:37:43.000Z</updated>
        <content type="html"><![CDATA[<h5 id="1-以下关于-function函数对象的说法不正确的是d">1、以下关于 Function函数对象的说法不正确的是（D ）</h5>
<pre><code class="language-js">A．函数可有可无返回值   
B．调用函数时传递的参数是实参 
C．函数调用时候，可以用一个变量来接收函数返回值 
D．函数必须要有形式参数 
</code></pre>
<h5 id="2-以下代码运行的结果是输出-b">2、以下代码运行的结果是输出( B)</h5>
<pre><code class="language-js">var a = b = 10;
(function () {
    var a = b = 20
})(); 
console.log(b); 
</code></pre>
<p>A．10     B．20     C．报错     D．undefined</p>
<h5 id="3-以下代码运行后的结果是输出-a">3、以下代码运行后的结果是输出( A  )</h5>
<pre><code class="language-js">var a = new Object();
a.name = &quot;admin&quot;;
console.log(a.name); 
</code></pre>
<p>A．admin  B．a    C．“admin”     D．[a]</p>
<h5 id="4-在-js-中15553-的运行结果是-c">4、在 JS 中，’1555’+3 的运行结果是(  C )</h5>
<p>A．1558     B．1552     C．15553     D．1553</p>
<h5 id="5-以下代码运行后弹出的结果是-b">5、以下代码运行后弹出的结果是(  B )</h5>
<pre><code class="language-js">var a = 888;
++a;
console.log(a++);
</code></pre>
<p>A．888     B．889     C．890     D．891</p>
<h5 id="6-关于变量的命名规则下列说法正确的是-abcde">6、关于变量的命名规则，下列说法正确的是（  ABCDE ）</h5>
<p>A．首字符必须是大写或小写的字母，下划线（_）或美元符（$）<br>
B．除首字母的字符可以是字母，数字，下划线或美元符<br>
C．变量名称不能是保留字<br>
D．长度是任意的<br>
E．区分大小写</p>
<h5 id="7-下列的哪一个表达式将返回值为假-b">7、下列的哪一个表达式将返回值为假（ B   ）</h5>
<p>A．!(3&lt;=1)<br>
B．(4&gt;=4)&amp;&amp;(5&lt;=2)<br>
C．(“a”==“a”)&amp;&amp;(“c”!=“d”)<br>
D．(2&lt;3)||(3&lt;2)</p>
<h5 id="8-下面代码k的运行结果是-b">8、下面代码，k的运行结果是（  B  ）</h5>
<pre><code class="language-js">var i = 0, j = 0;
for (i &lt; 10; j &lt; 6; i++ , j++) {
    k = i + j;
}
</code></pre>
<p>A．16     B．10     C．6     D．12</p>
<h5 id="9-下面代码的输出结果为-d">9、下面代码的输出结果为（ D ）</h5>
<pre><code class="language-js">var x = 1;
function fn(n) {
    n = n + 1;
};
y = fn(x);
console.log(y);
</code></pre>
<p>A．2     B．1     C．3     D．undefined</p>
<h5 id="10-1-2-3-4join0split的执行结果是-c">10、[1, 2, 3, 4].join(&quot;0&quot;).split(&quot;&quot;);的执行结果是（  C ）</h5>
<p>A．&quot;1,2,3,4&quot;<br>
B．[1,2,3,4]<br>
C．[“1”,“0”,“2”,“0”,“3”,“0”,“4”]<br>
D．”1,0,2,0,3,0,4&quot;</p>
<h5 id="11-下面代码的运行结果是-c">11、下面代码的运行结果是（   C）</h5>
<pre><code class="language-js">function fn1() {
    alert(1);
}
console.log(fn1);
</code></pre>
<p>A．1<br>
B．alert(1);<br>
C．function fn1() { alert(1); }<br>
D．Undefined</p>
<h5 id="12-以下代码运行后结果为-b">12、以下代码运行后，结果为（  B ）</h5>
<pre><code class="language-js">fn1();
var fn1 = function (a) {
    console.log(a);
} 
</code></pre>
<p>A．1     B．程序报错     C．alert(1);     D．undefined</p>
<h5 id="13-var-n-miao-wei-ke-tangindexofwei-6">13、var n = &quot;miao wei ke tang&quot;.indexOf(&quot;wei&quot;, 6);</h5>
<p>n的值为：（A   ）<br>
A．-1<br>
B．5<br>
C．程序报错<br>
D．-10</p>
<h5 id="14-下面对-substring-方法描述不正确的是-c">14、下面对 substring() 方法描述不正确的是（  C ）</h5>
<p>A．一共有两个参数，省略第二个参数表示从参数开始位置提、截取到字符串结束。<br>
B．提取之前会比较两个参数的大小，并根据大小调整位置。<br>
C．可以接收负数参数，负数表示从后往前数字符位置。<br>
D．如果没有设置参数，直接返回整个字符串。</p>
<h5 id="15-回答以下代码alert的值输出分别是多少-b">15、回答以下代码，alert的值输出分别是多少?( B)</h5>
<pre><code class="language-js">var a = 100;
function test(){
alert(a);
var a = 10;
alert(a);
}
test();
</code></pre>
<p>A、100 ，10  B、undefined，10    C、10，10     D、报错</p>
<h5 id="16-分析下段代码输出结果是b">16、分析下段代码输出结果是（B）</h5>
<pre><code class="language-js">var arr = [2, 3, 4, 5, 6];
var sum = 0;
for (var i = 1; i &lt; arr.length; i++) {
    sum += arr[i];
}
console.log(sum);
</code></pre>
<p>A．20     B．18     C．14     D．12</p>
<h5 id="17-回答以下代码alert的值输出分别是多少-a">17、 回答以下代码，alert的值输出分别是多少？( A)</h5>
<pre><code class="language-js"> var a = 100;
  function test() {
    alert(a);
    a = 10;
    alert(a);
  }
  test();
  alert(a);
</code></pre>
<p>A.100  10  10          B. 10  100  10<br>
C .10  10  100         D.100  100  100</p>
<h5 id="18-以下程序运行结束正确的是b">18、以下程序运行结束正确的是（B）</h5>
<pre><code class="language-js">var i = 10;
i++;
console.log(i);
var y = i++;
console.log(y);
y = ++i;
console.log(y);
y += 10;
console.log(y);
</code></pre>
<p>A.10 11 13 23      B. 11 11 13 23<br>
C.10 12 13 23      D.11 12 13 23</p>
<ol start="19">
<li>
<h5 id="下列代码的执结果是-a">下列代码的执结果是(  A )</h5>
</li>
</ol>
<pre><code class="language-js">function funcSwitch(sFlag) { 
    switch (sFlag) 
    { 
  case 'Test1': alert('Test1'); break; 
 case 'Test2': alert('Test2'); break;
 default: ;
     } 
    }
  funcSwitch('Test2');
</code></pre>
<p>A. Test2      B. Test1        C.undefined      D. null</p>
<h5 id="20下列代码的运行结果是-a">20.下列代码的运行结果是( A)</h5>
<pre><code class="language-js">var cars = ['BMW', 'Volvo', 'Saab', 'Ford'];
var i = 2, len = cars.length;
for (; i &lt; len; i++) {
  console.log(cars[i]);
}
</code></pre>
<p>A、SaabFord        B、 SaabVolvo<br>
C、 VolvoBMW      D、FordBMW</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML+CSS选择题]]></title>
        <id>https://zjp693.github.io/post/htmlcss-xuan-ze-ti/</id>
        <link href="https://zjp693.github.io/post/htmlcss-xuan-ze-ti/">
        </link>
        <updated>2020-03-07T16:36:52.000Z</updated>
        <content type="html"><![CDATA[<h4 id="单选题">单选题</h4>
<h5 id="1关于web标准下列说法正确的是-c">1.关于WEB标准下列说法正确的是：( 	C )</h5>
<p>A.html决定页面的行为，css决定页面的样式，js决定页面的结构。<br>
B.html决定页面的样式，css决定页面的结构，js决定页面的行为。<br>
C.html决定页面的结构，css决定页面的样式，js决定页面的行为。<br>
D.以上都不正确。</p>
<h5 id="2web标准里面规定三层分离不包括哪部分-d">2.web标准里面规定三层分离不包括哪部分( D )</h5>
<p>A.HTML<br>
B.CSS<br>
C.javsScript<br>
D.PHP</p>
<h5 id="3关于web标准下列说法正确的是-b">3.关于WEB标准下列说法正确的是 (	B	)</h5>
<p>A.html相当于人的动作行为，CSS相当于人的穿着打扮，JavaScript相当于人的骨架结构<br>
B.html相对于人的骨架结构，CSS相当于人的穿着打扮，JavaScript相当于人的动作行为<br>
C.html相当于人的穿着打扮，CSS相当于人的骨架结构，JavaScript相当于人的动作行为<br>
D.html相当于人的骨架结构，CSS相当于人的动作行为，JavaScript相当于人的穿着打扮</p>
<h5 id="4关于标签下列说法正确的是-b">4.关于标签下列说法正确的是 (	B	)</h5>
<p>A.P1是段落标签<br>
B.H1是标题标签<br>
C.Hr是换行标签<br>
D.Br是一条直线</p>
<h5 id="5关于标签下列说法不正确的是-b">5.关于标签下列说法不正确的是 (	B)</h5>
<p>A.H标签有6个等级分别是<h1>、<h2>、<h3>、<h4>、<h5>、<h6><br>
B.h1到h6文字从小到大（从大到小）<br>
C.p标签一行只能放一个（块元素独占一行）<br>
D.p是段落标签会给文字加上段落的语义</p>
<h5 id="6当网页显示图标时鼠标滑上图片显示文字描述是以下哪个属性b">6.当网页显示图标时，鼠标滑上图片显示文字描述是以下哪个属性(	B)</h5>
<p>A.设置alt属性(图片不显示的时候，显示的是alt设置的值)<br>
B.设置title属性(鼠标滑动到图片上显示的内容)<br>
C.设置href属性（没有这个属性）<br>
D.设置src属性 （这个是设置图片的链接地址）</p>
<h5 id="7在html中使用img标签插入图像下列选项关于img的src属性说法正确的是b">7.在HTML中，使用<img>标签插入图像，下列选项关于<img>的src属性说法正确的是(	B)</h5>
<p>A.用来设置图片的格式<br>
B.用来设置图片的所在位置 (src)<br>
C.用来设置鼠标指向图片时显示的文字(title)<br>
D.用来设置图片是否能正确显示（alt）</p>
<h5 id="8在html中关于a标签说法不正确的是c">8.在HTML中，关于a标签说法不正确的是(	C)</h5>
<p>A.a标签可以通过href属性跳转到另外一个页面<br>
B.a标签可以通过target属性设置是否在新窗口打开<br>
C.a标签只能在当前页面设置锚点链接，让用户能够快速定位到目标内<br>
D.a标签可以通过href=”#”设置一个空链接</p>
<h5 id="9在页面中看不见的表单元素是那种-c">9.在页面中看不见的表单元素是那种？( C)</h5>
<p>A  <input type="password">（设置密码的表单）<br>
B  <input type="radio">（设置单选框的表单）<br>
C  <input type="hidden">（设置隐藏域的表单）<br>
D  <input type="reset">（设置重置样式的表单）</p>
<h5 id="10如何显示没有下划线的超链接-a">10.如何显示没有下划线的超链接？ ( A)</h5>
<p>A. a {text-decoration:none}<br>
B a {text-decoration:no underline}<br>
C a {underline:none}<br>
D a {text-decoration:no underline}</p>
<h5 id="11css元素有哪几种显示方式-a">11.CSS元素有哪几种显示方式( A )</h5>
<p>A.block	inline	inline-block<br>
B.block 	none 	inline-block<br>
C.none	inline	inline-block<br>
D.block	inline	none</p>
<h5 id="12根据下列代码计算-盒子宽高下列说法正确的是a">12.根据下列代码计算 盒子宽高下列说法正确的是(A	)</h5>
<p>(A)	宽度为166px,高度为146px<br>
(B)	宽度为366px ,高度为 346px<br>
(C)	宽度为166px, 高度为346px<br>
(D)	宽度为306px，高度为306px</p>
<h5 id="13根据下列代码计算-盒子宽高下列说法正确的是a">13.根据下列代码计算 盒子宽高下列说法正确的是(	A)</h5>
<p>(A)宽度为126px,高度为126px<br>
(B)宽度为326px ,高度为 326px<br>
(C)宽度为166px, 高度为326px<br>
(D)宽度为306px，高度为306px</p>
<h5 id="14根据下列代码计算-盒子宽高下列说法正确的是a">14.根据下列代码计算 盒子宽高下列说法正确的是(A)</h5>
<p>(A)宽度为146px,高度为126px<br>
(B)宽度为326px ,高度为 326px<br>
(C)宽度为146px, 高度为326px<br>
(D)宽度为306px，高度为306px</p>
<p>(记住这个计算公式:)</p>
<p>盒子宽度计算: width+border-left+border-right+padding-left+padding-right<br>
盒子高度计算:height+border-top+border-bottom+padding-top+padding-bottom</p>
<h5 id="15关于html语义化以下哪个说法是正确的d">15.关于HTML语义化，以下哪个说法是正确的（D）？</h5>
<p>A: 语义化的HTML有利于机器的阅读，如PDA手持设备、搜索引擎爬虫；但不利于人的阅读</p>
<p>B: Table 属于过时的标签，遇到数据列表时，需尽量使用 div 来模拟表格</p>
<p>C: 语义化是HTML5带来的新概念，此前版本的HTML无法做到语义化</p>
<p>D: header、article、address都属于语义化明确的标签</p>
<h5 id="16制作移动端页面-以下哪种布局方式不合适c">16.制作移动端页面, 以下哪种布局方式不合适(C )</h5>
<p>A: A.响应式Responsive（使用@media媒体查询，给不同尺寸和介质的设备切换不同的样式）</p>
<p>B: B.伸缩Flexbox（使用CSS3 Flex系列属性进行相对布局）</p>
<p>C: C.固定Fixed（使用px和pt这样的绝对单位进行固定布局）</p>
<p>D: D.流动Fluid（使用%百分比进行相对布局）</p>
<h5 id="17下面选项中关于box-sizingborder-box的计算正确的是哪项d">17.下面选项中关于box-sizing:border-box的计算正确的是哪项（D）？</h5>
<p>A: 盒子实际宽度 = padding + content</p>
<p>B: 盒子实际宽度 = padding + margin</p>
<p>C: 盒子实际宽度 = content + padding + border +margin</p>
<p>D: 盒子实际宽度 = content + padding + border</p>
<h5 id="18如果想设置下列-the-first-paragraph标签的背景色为红色正确的是b">18.如果想设置下列” The first paragraph”标签的背景色为红色，正确的是（B）</h5>
<pre><code class="language-html">&lt; h1 &gt; This is a heading&lt;/h1 &gt;
&lt;p&gt;The first paragraph.&lt;/p&gt;
&lt;p&gt;The second paragraph.&lt;/p&gt;
&lt;p&gt;The third paragraph.&lt;/p&gt;
&lt;p&gt;The fourth paragraph.&lt;/p&gt;
</code></pre>
<p>A: p:nth-child(1){background:red};</p>
<p>B: p:nth-child(2){background:red};</p>
<p>C: p:nth-last-child(n){background:red};</p>
<p>D: p:nth-child(2n){background:red};</p>
<h5 id="19使用css的flexbox布局不能实现以下哪一个效果d">19.使用CSS的flexbox布局，不能实现以下哪一个效果（D）？</h5>
<p>A: 多列布局，随容器宽度等宽弹性伸缩</p>
<p>B: 多列布局，平均分配宽度</p>
<p>C: 多列布局，左列宽度像素数确定，中、右列随容器宽度等宽弹性伸缩</p>
<p>D: 多列布局， 不占有位置</p>
<h5 id="20以下位于-head-间的代码片段是做什么用的-meta-name-viewport-content-widthdevice-width-initial-scale1-d">20.以下位于 &lt; head &gt; 间的代码片段是做什么用的 &lt; meta name = &quot;viewport&quot; content = &quot;width=device-width, initial-scale=1&quot; &gt; （D）？</h5>
<p>A: 使得页面编码合乎移动端要求</p>
<p>B: 表示支持响应式设计</p>
<p>C: 添加后才能正常的缩放</p>
<p>D: 表示针对移动端进行适当的适配</p>
<h5 id="21以下哪个不是伪类选择器c">21.以下哪个不是伪类选择器（C）</h5>
<p>A: E:first-child;</p>
<p>B: E:last-child;</p>
<p>C: E:before;</p>
<p>D: E:nth-child(n);</p>
<h5 id="22伪元素选择器beforeafter必须包含的属性是c">22.伪元素选择器before&amp;after必须包含的属性是（C）</h5>
<p>A: position;</p>
<p>B: display;</p>
<p>C: content;</p>
<p>D: background;</p>
<h5 id="23css3中设置边框阴影的属性是a">23.CSS3中设置边框阴影的属性是（A）</h5>
<p>A: box-shadow;</p>
<p>B: text-shadaow;</p>
<p>C: text-align;</p>
<p>D: text-direction;</p>
<h5 id="24在调用动画中animation-delay属性的作用是b">24.在调用动画中animation-delay属性的作用是（B）</h5>
<p>A:  设置动画动画执行速度;</p>
<p>B:  设置动画延迟;</p>
<p>C:  设置动画名称;</p>
<p>D:  设置动画执行次数;</p>
<h5 id="25指定一个盒子为伸缩盒子需要设置的属性是c">25.指定一个盒子为伸缩盒子需要设置的属性是（C）</h5>
<p>A: display:block;</p>
<p>B: display:none;</p>
<p>C: display:flex;</p>
<p>D: display:inline;</p>
<h5 id="26sass中-变量的命令使用什么符号开头a">26.sass中 变量的命令使用什么符号开头（A）</h5>
<p>A: $;</p>
<p>B: @;</p>
<p>C: &amp;;</p>
<p>D: *;</p>
<h5 id="27一个a标签想实现一个圆那么以下样式书写正确的是c">27.一个a标签，想实现一个圆，那么以下样式书写正确的是（C）</h5>
<p>A: a{display：block;width:20px;height:20px;border:5px solid #f00;border-radius:10px;}</p>
<p>B: a{display：block;width:20px;height:20px;border:5px solid #f00;border-radius:5px;}</p>
<p>C: a{display：block;width:20px;height:20px;border:5px solid #f00;border-radius:50%;}</p>
<p>D: a{display：block;width:20px;height:20px;border:5px solid #f00;border-radius:14px;}</p>
<h5 id="28下面关于背景样式说法不正确的是a">28.下面关于背景样式，说法不正确的是（A）</h5>
<p>A: 默认情况下， 背景图片是不平铺的</p>
<p>B: color设置的是文本颜色， background-color设置的是背景颜色</p>
<p>C: CSS Sprite技术是借助background-position属性来实现的</p>
<p>D: 我们可以使用”background-repeat:repeat-x”,来实现背景图片在x轴方向平铺</p>
<h5 id="29在移动端如果想要设置用户不可进行缩放以下代码中正确的是哪一个d">29.在移动端如果想要设置用户不可进行缩放，以下代码中正确的是哪一个？（D）</h5>
<pre><code class="language-css">A: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; &gt;

B: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=2.0&quot; &gt;

C: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1.0&quot; &gt;

D: &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot; &gt;
</code></pre>
<h5 id="30下面哪个单位取决于html标签的font-size属性的值b">30.下面哪个单位，取决于html标签的font-size属性的值？（B）</h5>
<p>A: em</p>
<p>B: rem</p>
<p>C: px</p>
<p>D: pt</p>
<h5 id="31关于定位错误的是c">31.关于定位，错误的是：（C）</h5>
<p>A: z-index后面的数字越大在层叠样式中越居上，如：z-index:5在z-index:1上面</p>
<p>B: z-index数字后面不加单位，如：z-index:100;</p>
<p>C: 如果z-index的数值相同，先书写的在上面</p>
<p>D: 只有绝对定位，固定定位，相对定位，有此属性</p>
<h5 id="32移动端页面布局中以下描述不正确的是c">32.移动端页面布局中,以下描述不正确的是:（C）</h5>
<p>A:  父盒子设为Flex以后，子元素的float属性将失效。</p>
<p>B:  flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
<p>C:  justify-content属性定义了项目在侧轴上的对齐方式。</p>
<p>D:  space-around：项目之间的间隔比项目与边框的间隔大一倍。</p>
<h5 id="33视口中-能够控制最大缩放的属性是d">33.视口中, 能够控制最大缩放的属性是（D）</h5>
<p>A: width;</p>
<p>B: user-scalable;</p>
<p>C: initial-scale;</p>
<p>D: maximun-scale;</p>
<h5 id="34关于伪元素的选项错误的是b">34.关于伪元素的选项错误的是（B）？</h5>
<p>A: ::before、::after是行内元素</p>
<p>B: 不使用content属性，也可以显示</p>
<p>C: 不可以使用JS控制</p>
<p>D: 最初伪元素的语法是使用“:”（一个冒号），在CSS3中伪元素使用“::”（两个冒号）</p>
<h4 id="多选题">多选题</h4>
<h5 id="下列哪些是css3的新特性多选abcde">下列哪些是CSS3的新特性【多选】（ABCDE）？</h5>
<p>A: 3D变换</p>
<p>B: 渐变</p>
<p>C: 2D变换（平移，缩放，旋转）</p>
<p>D: 媒体查询(新增媒体属性比如min-width)</p>
<p>E: CSS动画</p>
<h5 id="2以下关于less的使用正确的是abc">2.以下关于less的使用正确的是:（ABC）</h5>
<p>A:  Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、函数等特性，使 CSS 更易维护和扩展;</p>
<p>B:  如果需要直接引用写好的less文件, 只要在less样式表之前引入less.js文件即可;</p>
<p>C:  Less中可以直接进行数值运算;</p>
<p>D:  @import 的位置可随意放置;</p>
<h5 id="3以下媒体查询的描述说明正确的是多选abc">3.以下媒体查询的描述说明正确的是【多选】（ABC）？</h5>
<p>A: min-width：在pc端和移动端能正常的响应，效果一致</p>
<p>B: 如果是判断的是 min-width，那么范围区间应该从小到大写</p>
<p>C: 如果是判断的是 max-width，那么范围区间就应该从大到小写</p>
<p>D: 如果是判断的是 mid-width，那么范围区间就应该从中间位置写</p>
<h5 id="4rem与em的相关描述正确的是bcd">4.rem与em的相关描述正确的是:（BCD）</h5>
<p>A:  rem与em都是相对单位，我们使用它们的目的是为了适应各种手机屏幕;</p>
<p>B: rem和em都是是根据元素字体大小来进行计算的;</p>
<p>C: em是相对于父级元素的单位，会随父级元素的属性（font-size）变化而变化;</p>
<p>D:  rem是相对于根目录（HTML元素）的，所以它会随HTML元素的属性（font-size）变化而变化;</p>
<h5 id="5下面哪个媒体查询无法实现abcd">5.下面哪个媒体查询无法实现:（ABCD）</h5>
<p>A:  @media screen and(max-width:500px){ };</p>
<p>B:  @media screenand (max-width:500px){ };</p>
<p>C:  @media screen and (max-width:500px;){ };</p>
<p>D:  @ media screen and (max-width:500px){ };</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML+CSS简答题]]></title>
        <id>https://zjp693.github.io/post/htmlcss-jian-da-ti/</id>
        <link href="https://zjp693.github.io/post/htmlcss-jian-da-ti/">
        </link>
        <updated>2020-03-07T15:22:23.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h5 id="1怎么让一个不定宽高的div水平垂直居中最少2种方式实现">1.怎么让一个不定宽高的div水平垂直居中？（最少2种方式实现）</h5>
<pre><code class="language-css">方式一：margin：auto：
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;

方式二translate：
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);

方式三flex：
    /* 给父盒子添加 */
    display: flex;
justify-content: center;
align-items:center;
</code></pre>
<p>2.请简述用css如何实现左侧宽度固定，右侧宽度自适应(用2种方式实现)<br>
方式一flex法：</p>
<pre><code class="language-css">html代码
 &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-css">css代码
html,body {
      display: flex;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

.left {
  width: 200px;
  height: 100%;
  background-color: red;
}

.right {
  flex: 1;
  background-color: blue;
}
</code></pre>
<p>方式二浮动法：<br>
Html代码</p>
<pre><code class="language-html">  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码</p>
<pre><code class="language-css">    html,
    body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    position: relative;
  }

.left {
  float: left;
  width: 200px;
  height: 100%;
  background-color: red;
}
css
.right {
  height: 100%;
  /* 挤开左边盒子 */
  margin-left: 200px;
  background-color: blue;
}
</code></pre>
<h5 id="3请简述em和rem的区别">3请简述em和rem的区别？</h5>
<pre><code>em相对于元素的字体大小来计算，如果元素没有字体大小 ，则继续向上查找，直至有设置字体大小的元素，如果一直没有，就是根据浏览器默认的字体大小进行计算。
rem是根据html元素字体大小进行计算的
</code></pre>
<h5 id="4请简述css3有哪些新特性列举五个单词和汉语都写">4.请简述CSS3有哪些新特性，列举五个,(单词和汉语都写)</h5>
<pre><code>圆角:border-radius, 盒子阴影：box-shadow，动画:animation,  过渡:transition,旋转:rotate
</code></pre>
<h5 id="5请详细css的三大特性分别是什么">5.请详细CSS的三大特性分别是什么？</h5>
<pre><code class="language-css">层叠性：当相同选择器中存在了相同的属性时，根据就近原则，最下面的属性值覆盖上面的属性值

继承性：子元素继承父元素的某些样式，比如以text-、font-、line-等元素开头的样式，还有color样式可以被继承

优先级性：在将多个选择器应用于同一个标签时，根据权重所要优先选择哪个样式，就是优先级性
</code></pre>
<h5 id="6请简述什么是外边距塌陷并且怎么解决">6.请简述什么是外边距塌陷，并且怎么解决？</h5>
<pre><code class="language-css">外边距塌陷：假设b是a的子盒子，给子盒子b设置了外边距margin-top，a和b都会被向下移动
解决办法：

给父元素添加 border属性

给父元素添加 overflow: hidden (溢出: 隐藏)
</code></pre>
<h5 id="7请简述用两种方式实现三栏布局">7.请简述用两种方式实现三栏布局？</h5>
<p>方式一定位法：<br>
html代码：</p>
<pre><code class="language-html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码</p>
<pre><code class="language-css">html,
body {
position: relative;
width: 100%;
height: 100px;
    
/* 重置样式 */
margin: 0;
padding: 0;
}

/* 左定位 */
.left {
position: absolute;
top: 0;
left: 0;
width: 100px;
height: 100%;
background-color: red;
}

/* 中间自适应 */
.center {
height: 100%;
background-color: pink;

/* 挤开左右 */
margin-left: 100px;
margin-right: 100px;
}

/* 右定位 */
.right {
position: absolute;
top: 0;
right: 0;
width: 100px;
css
height: 100%;
background-color: blue;
}
</code></pre>
<p>方式二flex法：<br>
html代码：</p>
<pre><code class="language-html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码</p>
<pre><code class="language-css">html,
body {
/* 伸缩盒子 */
display: flex;
width: 100%;
height: 100px;

/* 重置样式 */
margin: 0;
padding: 0;
}

.left {
width: 100px;
height: 100%;
background-color: red;
}

.center {
/* 剩余空间占比 */
flex: 1;
background-color: pink;
}

.right {
width: 100px;
height: 100%;
background-color: blue;
}
</code></pre>
<h5 id="8请简述css中-link-和import-的区别是什么">8.请简述CSS中 link 和@import 的区别是什么？</h5>
<pre><code class="language-css">a. link属于HTML标签，而@import是CSS提供的，且只能加载 CSS
b. 页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完后再加载
c. @import只在IE5以上才能识别，而link是HTML标签，无兼容问题
d. link引入方式的权重 高于@import的权重
</code></pre>
<h5 id="9请简述css样式中rgba和opacity的透明效果有什么不同">9.请简述css样式中rgba()和opacity的透明效果有什么不同？</h5>
<pre><code class="language-css">a.opacity作用于元素，以及元素内的所有内容的透明度，rgba()只作用于元素的颜色或其背景色。
b. 设置rgba透明的元素的子元素不会继承透明效果
</code></pre>
<h5 id="10-行内元素和块级元素的区别是什么怎么将行内元素转为块级元素">10、行内元素和块级元素的区别是什么？怎么将行内元素转为块级元素？</h5>
<p>行内元素：<code>相邻行内元素在一行上，一行可以显示多个，不能设置宽高、内边距、外边距，只能嵌套文本和其他行内元素，默认宽度就是它本身内容的宽度。</code></p>
<p>块级元素：<code>独占一行，可以设置宽高、内边距、外边距，可以嵌套行内或块级元素，且文字类的块级元素不能放其他块级元素，宽度默认是容器(父级宽度)的100%。</code></p>
<p>行内元素转块级元素：<code>使用display: block(转换: 块级) 进行转换。</code></p>
<h5 id="11-行内元素有哪些块级元素有哪些行内块元素有哪些">11、行内元素有哪些？块级元素有哪些？行内块元素有哪些？</h5>
<p>行内元素有：<code>&lt;a&gt;、加粗(&lt;b&gt;、&lt;strong&gt;)、斜体（&lt;i&gt;、&lt;em&gt;）、删除线（&lt;s&gt;、&lt;del&gt;）、变小&lt;small&gt;、&lt;span&gt;、、</code></p>
<p>块级元素有：<code>&lt;p&gt;、&lt;h1&gt;到&lt;h6&gt;、&lt;div&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;table&gt;、&lt;tr&gt;、&lt;td&gt;、&lt;th&gt;、、</code></p>
<p>行内块元素有：<code>常见的&lt;img&gt;、&lt;input&gt;、&lt;td&gt;、、、、（具有行内和块级共同特性的元素）</code></p>
<h5 id="12-块元素有什么特点行内元素有什么特点">12、块元素有什么特点？行内元素有什么特点？</h5>
<p>块元素的特点是：<code>独占一行，可以设置宽高、内边距、外边距，可以嵌套行内或块级元素，且文字类的块级元素不能放其他块级元素，宽度默认是容器(父级宽度)的100%。</code></p>
<p>行内元素的特点是：<code>相邻行内元素在一行上，一行可以显示多个，不能设置宽高、内边距、外边距，只能嵌套文本和其他行内元素，默认宽度就是它本身内容的宽度。</code></p>
<h5 id="13-css的复合选择器有哪些举列子说明">13、css的复合选择器有哪些？举列子说明</h5>
<p>复合选择器有：</p>
<ul>
<li>
<p>后代选择器：<code>div div span {color: red};（选择的是div下的div下的span标签）</code></p>
</li>
<li>
<p>子代选择器：<code>div &gt; p {color: red};（选择的是div下的p标签(亲儿子)）</code></p>
</li>
<li>
<p>并集选择器：<code>div,span,p {color: red}; （选择的是div标签和span标签和p标签）</code></p>
</li>
<li>
<p>伪类选择器：<code>a: hover {color: green};（鼠标悬停在超链接上会显示出的样式(绿色的字体)）</code></p>
</li>
</ul>
<h5 id="14-背景的属性有哪些分别是什么作用">14、背景的属性有哪些？分别是什么作用？</h5>
<ul>
<li>
<p>背景颜色【background-color：选择引入颜色的格式】：<code>给元素添加背景颜色</code></p>
</li>
<li>
<p>背景图片【background-image：url(图片路径);】：<code>给元素添加背景图(默认全局平铺)</code></p>
</li>
<li>
<p>背景平铺方式【background-repeat：】：<code>给背景选择平铺的方式</code></p>
</li>
</ul>
<pre><code class="language-html">&lt;!--
	平铺方式的参数有:
	● 参数值：'repeat'
	  含义：背景图像在横向和纵向上平铺(默认)
	● 参数值：'no-repeat'
	  含义：背景图像不平铺，只显示一个	
	● 参数值：'repeat-x'
	  含义：背景图像在横向上平铺
	● 参数值：'repeat-y'
	  含义：背景图像在纵向上平铺
--&gt;
</code></pre>
<p>背景图片位置【background-position：水平位置  竖直位置】：<code>给图片选择所处位置</code></p>
<pre><code class="language-html">&lt;!--
	图片位置的参数有：
	● 参数值：length
	  含义：百分数| 由浮点数字和单位标识符组成的长度值
	● 参数值：position
	  含义：top | center | bottom | left | center | right 方位名词
--&gt;
</code></pre>
<h5 id="15-css的三大特性分别是什么请详细说明并且举例子">15、css的三大特性分别是什么，请详细说明，并且举例子</h5>
<p>层叠性：<code>层叠也叫覆盖，特点是：在相同选择器中存在相同属性时，根据就近原则，最下面的覆盖上面的。</code></p>
<pre><code class="language-css">	例子：
	div {
	color: red;
	}
	div{
	color: blue;
	}
	div{
	color: green;
	}
	【div的color的结果是绿色】
</code></pre>
<p>继承性：<code>相当于儿子继承老爹的财产，称作富二代。继承性的特点就是：父元素有的样式，子元素自然也能有，比如以text-，font-，line-等元素开头的样式，还有color。恰当的使用继承可以简化代码，降低css样式的复杂性。</code></p>
<pre><code class="language-html">&lt;!-- 例子：
	ul {
	font-size: 20px;
	color: red; 
	}
	【对于ul下的li标签里面的文字大小就是20px，文本颜色就是红色】

--&gt;
</code></pre>
<p>优先级性：<code>在将多个选择器应用于同一个标签时，所要优先选择哪个样式，就是优先级性，如果选择器相同，那么就考虑层叠性；如果选择器不同，那么根据选择器权重进行选择样式</code></p>
<pre><code class="language-html">&lt;!--
		○ 选择器：继承(子承父) 或 *(通配符)
          选择器权重：0, 0, 0, 0
		○ 选择器：标签选择器
          选择器权重：0, 0, 0, 1
		○ 选择器：类选择器 伪类选择器
          选择器权重：0, 0, 1, 0
		○ 选择器：ID选择器
          选择器权重：0, 1, 0, 0
		○ 选择器：行内样式 style=&quot;&quot;
          选择器权重：1, 0, 0, 0
		○ 属性值后面加：!important（代表至高无上的权重）
               该权重：无穷大+∞

--&gt;
</code></pre>
<h5 id="16-css哪些属性能够继承举例不得少于5个">16、css哪些属性能够继承，举例不得少于5个</h5>
<pre><code class="language-html">&lt;!--【颜色属性】--&gt;
&lt;color&gt;  注：background-color不具备继承性！

&lt;!--【text-开头的属性】--&gt;
&lt;text-decoration(文本装饰)、text-align(文本水平对齐方式)、text-indent(首行缩进)、、、&gt;

&lt;!--【font-开头的属性】--&gt;
&lt;font--size(字体大小)、font-family(字体种类)、font-weight(字体粗细)、font-style(字体风格)、、&gt;

&lt;!--【line-开头的属性】--&gt;
&lt;line-height(行高)、、&gt;    
</code></pre>
<h5 id="17-css权重计算规则">17、css权重计算规则</h5>
<pre><code class="language-html">&lt;!-- 权重计算例子如下： --&gt;
&lt;style&gt;
	/*❶ 0001 + 0001 + 0001 = 0003 */
	div ul li{}
    /*❷ 0010 + 0001 + 0001 = 0012 */
    .box ul li{} 
    /*❸ 0001 + 0001 = 0002 */
    ul li{}
    /*❹ 0001 */
    li{}
&lt;/style&gt;
&lt;!-- 因为：❷ &gt; ❶ &gt; ❸ &gt; ❹ --&gt;
&lt;!--【所以：最后选择权重最高的那个❷】--&gt;
&lt;!--【可根据个人计算习惯，结果正确即可】--&gt;
</code></pre>
<h5 id="18-浮动的元素有什么特点">18、浮动的元素有什么特点</h5>
<p>浮动元素的特点：</p>
<ul>
<li>会脱离普通(标准)流，好比进入另一个平面，与原来平面的元素不会产生实际影响，可指定浮动元素所要处在的位置</li>
<li>浮动后会在一行上显示，相邻浮动元素之间无间隙</li>
<li>会根据父盒子的宽度自动换行</li>
<li>如果没有给盒子设置宽度，会默认其宽度和父盒子一样，当给盒子添加浮动后，又会默认宽度跟着内容变化</li>
<li>任何元素皆可浮动，添加浮动后的元素具备与行内块元素相似的特性</li>
</ul>
<h5 id="19-清除浮动的方式把学过的都写出来非常重要">19、清除浮动的方式，把学过的都写出来，（非常重要）</h5>
<ul>
<li>给父盒子设置一个大于浮动元素的高从而包裹浮动元素<code>（视觉上清除浮动）</code></li>
<li>给父元素添加 <code>overflow:hidden(溢出:隐藏);</code> 样式</li>
</ul>
<h5 id="20css的三种引入方式分别是什么">20.CSS的三种引入方式分别是什么？</h5>
<p>1.行内式<br>
<code>&lt;标签 style=&quot;css属性:属性值;…&quot;&gt;&lt;/标签&gt;</code><br>
2.内嵌式</p>
<pre><code class="language-html">在head标签中写

&lt; style &gt;

标签名{ css属性: 属性值; … }

&lt;/style &gt;
</code></pre>
<p>3.外链式<br>
样式先写在css文件中，再使用link标签引入css文件</p>
<h5 id="21什么是外边距合并怎么解决把方法都写出来">21.什么是外边距合并，怎么解决，把方法都写出来</h5>
<p>外边距合并：竖直排列的两个盒子，如果两个盒子其中一个盒子添加了属性margin-top,另一个盒子添加了属性margin-bottom，那么两个盒子之间的距离等于最大的那个盒子的外边距而不是两者的外边距之和。<br>
解决办法：<br>
只给其中一个添加外边距</p>
<h5 id="22什么是外边距塌陷怎么解决把方法都写出来">22.什么是外边距塌陷，怎么解决，把方法都写出来</h5>
<p>外边距塌陷：<code>假设b是a的子盒子，给子盒子b设置了外边距margin-top，a和b都会被向下移动</code><br>
解决办法：</p>
<ul>
<li>给父元素添加 border属性</li>
<li>给父元素添加 overflow: hidden (溢出: 隐藏)</li>
</ul>
<h5 id="23复合选择器有哪些标志分别是什么">23.复合选择器有哪些，标志分别是什么？</h5>
<ul>
<li>后代选择器，标志是&quot;空格&quot;</li>
<li>子代选择器，标识是&quot;&gt;&quot;</li>
<li>并集选择器，标志是&quot;,&quot;</li>
<li>伪类选择器，标志是&quot;:&quot;</li>
</ul>
<h5 id="24元素显示模式有哪些分别列举3个该模式的标签">24.元素显示模式有哪些？分别列举3个该模式的标签</h5>
<ul>
<li>块元素 标签有：<code>div、h1~h6、ol、ul、li、p、table、、、</code></li>
<li>行内元素 标签有：<code>span、a、b(加粗)、strong、i(斜体)、em、、、</code></li>
<li>行内块元素 标签有：<code>img、input、、textarea、、、</code></li>
</ul>
<h5 id="25css3的三大特性分别是什么">25.CSS3的三大特性分别是什么？</h5>
<p>层叠性：当相同选择器中存在了相同的属性时，根据就近原则，最下面的属性值覆盖上面的属性值</p>
<p>继承性：子元素继承父元素的某些样式，比如以text-、font-、line-等元素开头的样式，还有color样式可以被继承</p>
<p>优先级性：在将多个选择器应用于同一个标签时，根据权重所要优先选择哪个样式，就是优先级性</p>
<h5 id="26权重的优先级顺序">26.权重的优先级顺序</h5>
<p>继承(子承父)或*(通配符) &lt; 标签选择器 &lt; 类选择器 = 伪类选择器 &lt; ID选择器 &lt; 行内样式 &lt; !important(权重无穷大)</p>
<h5 id="27清除浮动都有哪些方法具体说明">27.清除浮动都有哪些方法(具体说明)？</h5>
<pre><code class="language-css">清除浮动的方法：1. 隔墙法（额外标签法）：
在最后一个浮动元素末尾，添加一个空的标签， 添加clear: both样式     
例如：&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;

overflow法：
给父元素添加属性：overflow: hidden;（溢出: 隐藏）;

单伪元素法：
给父元素添加after伪元素：
元素:after{
content: &quot;&quot;;
display: block;
height: 0;
clear: both;
}

双伪元素法：
给父元素添加before和after两个伪元素：
  .clearfix:before,
.clearfix:after {	  
 content: &quot;&quot;;
 display: table;	  
 }
.clearfix:after {
  clear: both;
 } 
.clearfix {
 *zoom: 1;
}
</code></pre>
<h5 id="28定位有哪些他们定位的参照物是什么">28.定位有哪些？他们定位的参照物是什么？</h5>
<ul>
<li>静态定位：代表无定位，无参照物</li>
<li>相对定位：定位的参照物是自身</li>
<li>绝对定位：定位的参照物是最近的那个有定位的祖先元素</li>
<li>固定定位：定位的参照物是浏览器的可视窗口</li>
</ul>
<h5 id="29元素的显示和隐藏方法有哪些">29.元素的显示和隐藏方法有哪些？</h5>
<pre><code class="language-css">1.display属性
  display: none;代表隐藏
  display: block;代表显示
2.visibility属性
  visibility: hidden;代表隐藏
  visibility /vɪzɪ'bɪlɪtɪ/: visible /ˈvɪzəbl/
3.overflow属性
  overflow: hidden;代表超出隐藏
  overflow: visible;代表显示
</code></pre>
<h5 id="30dispaly-none和visibility-hidden的区别是什么">30.dispaly: none和visibility: hidden的区别是什么？</h5>
<pre><code class="language-css">display: none;是彻底消失，隐藏时不会占位
visibility: hidden;是视觉上的消失，隐藏时仍然占位
</code></pre>
<h5 id="31图片标签是什么其属性有哪些至少四个">31.图片标签是什么，其属性有哪些（至少四个）</h5>
<p><code>&lt;img&gt;</code>   	<code>src图片路径</code> <code>title鼠标移动显示内容</code> <code>alt图片无法显示的时候显示内容</code> <code>width 图片宽</code> <code>height图片高</code><br>
链接是什么，其属性有哪些（至少三个）<br>
<a>标签	 <code>herf路径</code> <code>title提示标题</code> <code>target在新网页打开</code></p>
<h5 id="32文件路径有哪些">32.文件路径有哪些</h5>
<p>绝对路径：直接写网址<br>
相对路径：<code>./</code>当前     <code>../</code>上一层</p>
<h5 id="33有序列表和无序列表的标签是什么">33.有序列表和无序列表的标签是什么</h5>
<pre><code class="language-html">有序：&lt;ol&gt;
	&lt;li&gt;&lt;li&gt;
	&lt;/ol&gt;
无序:&lt;ul&gt;m
	&lt;li&gt;&lt;li&gt;
	&lt;/ul&gt;
</code></pre>
<h5 id="34css的三种书写方式是什么">34.css的三种书写方式是什么</h5>
<pre><code class="language-html">行内    &lt;标签 style=&quot;css属性名: 属性值;css属性名: 属性值;css属性名: 属性值;...&quot;&gt;&lt;/标签&gt;
 内嵌 &lt;head&gt;
     &lt;style&gt;
      选择器{
     属性名：属性值；
	&lt;/style&gt;
	&lt;/head&gt;
</code></pre>
<h5 id="35css选择器有哪些">35.css选择器有哪些</h5>
<p>id选择器</p>
<p>类选择器</p>
<p>通配符选择器</p>
<p>标签选择器</p>
<h5 id="36src和href的区别是什么">36.src和href的区别是什么</h5>
<p>src的内容是页面不可少的一部分 是引入<br>
href的内容是与该页面有关联 是引用</p>
<h5 id="37什么是外边距塌陷怎么解决把方法都写出来">37.什么是外边距塌陷，怎么解决，把方法都写出来</h5>
<p>假设b是父级盒子 a是子级 当给a margin-top时候 b本应该不动 但是却随a动了<br>
解决办法：给父元素添加border<br>
给父元素overflow：hidden</p>
<h5 id="38什么是外边距合并怎么解决把方法都写出来">38.什么是外边距合并，怎么解决，把方法都写出来、</h5>
<p>当两个盒子上下挨着且上下都有margin时候 他们的距离<br>
本应该是两个外边距的和 但却是最大的一个外边距<br>
解决方案：只给一个就可以</p>
<h5 id="39什么是盒模型一个盒子的width200pxpadding20pxborder1px-solid-ccc盒子的实际宽度是多少怎么计算的">39.什么是盒模型，一个盒子的width:200px,padding:20px,border:1px solid #ccc，盒子的实际宽度是多少，怎么计算的？</h5>
<p>盒子本身宽度200px   加上外边距左右20一共40 还有1px实线  左右两边 所以再加2px  等于242px</p>
<h5 id="40表格标签有哪些属性有哪些至少3个">40.表格标签有哪些，属性有哪些（至少3个）</h5>
<pre><code class="language-css">&lt;tr&gt; 行  &lt;td&gt;列  &lt;th&gt;单元格标题
border给table标签和td添加边框
cellspacing 设置单元格之间的距离
cellpadding 设置内容与单元格边框之间的距离
rowspan 跨行 从自己算1 跨一行+1
colspan 跨列 从自己算1 跨一行+1
</code></pre>
<h5 id="41如何合并单元格的行和列">41.如何合并单元格的行和列</h5>
<pre><code class="language-css">rowspan 跨行 从自己算1 跨一行+1
colspan 跨列 从自己算1 跨一行+1
</code></pre>
<h5 id="42文本装饰属性是什么其属性值有哪些至少3个">42.文本装饰属性是什么，其属性值有哪些（至少3个）</h5>
<pre><code class="language-css">text-decoration
none 取消装饰
underline 下划线
overline 上边线
line-through 删除线
</code></pre>
<h5 id="43怎么让元素垂直居中属性是哪个">43.怎么让元素垂直居中，属性是哪个</h5>
<pre><code class="language-css">让文字等于行高
line-height=行高
</code></pre>
<h5 id="44怎么让元素水平居中属性是哪个">44.怎么让元素水平居中，属性是哪个</h5>
<pre><code class="language-css">text-glign：center 居中
left 左对齐  right右对齐
</code></pre>
<h5 id="45字体大小-种类-粗细-风格的属性和属性值有哪些">45.字体大小、种类、粗细、风格的属性和属性值有哪些</h5>
<pre><code class="language-css">字体大小 font-size
字体种类 fout-family
字体粗细 font-weight
字体样式 font-style
normal正常  italic斜体
</code></pre>
<h5 id="46个标签可以有几个伪元素分别是哪几个">46.个标签可以有几个伪元素，分别是哪几个</h5>
<pre><code class="language-css">两个  before和after
</code></pre>
<h5 id="47怎么让一个不定宽高的盒子在另一个盒子中水平垂直居中写2种方式">47.怎么让一个不定宽高的盒子在另一个盒子中水平垂直居中（写2种方式）</h5>
<pre><code class="language-css">方式一margin：auto：
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
	margin: auto;

方式二translate：
    position: absolute;
    top: 50%;
    left: 50%;
	transform: translate(-50%, -50%);

方式三flex：
    /* 给父盒子添加 */
    display: flex;
	justify-content: cent ;
    align-items: center;
</code></pre>
<h5 id="48精灵图的使用方法">48.精灵图的使用方法？</h5>
<ul>
<li>定宽高，存放所需的精灵图</li>
<li>添加background-image: url(&quot;精灵图路径&quot;); 引入精灵图</li>
<li>调整位置选择需要的精灵图：background-position: -x -y;</li>
<li>如果需要再调整精灵图大小使用：background-size: ;</li>
</ul>
<h5 id="49em和rem的区别是什么">49.em和rem的区别是什么？</h5>
<p>em相对的是当前元素文本字体大小计算，如没有则相对浏览器默认的font-size值计算</p>
<p>rem相对的是根元素html的字体大小进行计算的</p>
<h5 id="50css中-link-和import-的区别是什么">50.CSS中 link 和@import 的区别是什么？</h5>
<p>a. link属于HTML标签，而@import是CSS提供的，且只能加载 CSS<br>
b. 页面被加载时，link会同时被加载，而@import引用的CSS会等到页面被加载完后再加载<br>
c. @import只在IE5以上才能识别，而link是HTML标签，无兼容问题<br>
d. link引入方式的权重,高于@import的权重</p>
<h5 id="51rgba和opacity的透明效果有什么不同">51.rgba()和opacity的透明效果有什么不同？</h5>
<p>a.opacity作用于元素，以及元素内的所有内容的透明度，rgba()只作用于元素的颜色或其背景色。</p>
<p>b. 设置rgba透明的元素的子元素不会继承透明效果</p>
<h5 id="52image标签上title属性与alt属性的区别是什么">52.<image>标签上title属性与alt属性的区别是什么？</h5>
<p>title属性：鼠标移到图片上显示&quot;标题内容&quot;</p>
<p>alt属性：当<img>加载不出来的时候，alt属性内容会替代<img>显示</p>
<h5 id="53css元素的三种显示模式">53.CSS元素的三种显示模式？</h5>
<p>行内元素：inline</p>
<p>块元素：block</p>
<p>行内块元素：inline-block</p>
<h5 id="54行内元素有哪些块级元素有哪些行内块元素有哪些">54.行内元素有哪些？块级元素有哪些？行内块元素有哪些？</h5>
<p>行内元素：<br>
span、a、b (加粗)、strong、s (删除线)、del、i (斜体)、em、、、、、、、</p>
<p>块级元素：<br>
h1~h6、p、div、ul、ol、li、、、、、、</p>
<p>行内块元素：<br>
input、img、textarea、</p>
<h5 id="55请至少写出5个h5的新标签">55.请至少写出5个H5的新标签？</h5>
<pre><code class="language-html">&lt; header &gt;&lt;/header &gt;  // 头部 
&lt;nav&gt;&lt;/nav&gt;     // 导航
&lt;main&gt;&lt;/main&gt;    // 主体
&lt;aside&gt;&lt;/aside&gt;   // 侧边
&lt;footer&gt;&lt;/footer&gt;  // 底部
</code></pre>
<ol start="56">
<li>
<h5 id="怎么定义动画怎么使用动画">怎么定义动画？怎么使用动画？</h5>
</li>
</ol>
<p>定义：<br>
<code>@keyframes</code> 动画名字 {<br>
&quot;定义需要的动画&quot;<br>
}<br>
使用：<br>
给需要的元素添加<code>animation</code>: 动画名 动画完成所需时间 动画速度 延迟、、、</p>
<p>具体代码：</p>
<pre><code class="language-css">定义动画1：from、to动画
@keyframes 动画名 {
            from {
                开始状态;
            }
            to {
                结束状态
            }
        }
定义动画2：百分比动画
@keyframes 动画名 {
            0% {
                开始状态
            }
            ···
            50% {
                过程n状态
            }
            ···
            100% {
                结束状态
            }
        }
使用：
/* 规定的动画名 */
            animation-name: name;
            /* 动画所需时长 */
            animation-duration: 时间;
            /* 动画运动曲线 */
            animation-timing-function: linear;
            /* 动画延迟时间（多久后开始动画） */
            animation-delay: 时间;
            /* 动画播放次数 */
            animation-iteration-count: infinite;

连写：animation: 动画名 运动所需时长 ···;没有顺序要求，也可缺省书写，但是动画名和所需时长必写，当同时出现动画时长和动画延迟时左数第一个会被识别为时长
</code></pre>
<h5 id="57说明css渐变有哪些分别是什么怎么使用">57.说明CSS渐变有哪些？分别是什么？怎么使用？</h5>
<ul>
<li>线性渐变：<code>linear-gradient</code>: 方向 初始色 结束色</li>
<li><code>background-image: linear-gradient</code>(to  渐变的最终方向, 初始颜色 最终颜色);</li>
<li>径向(圆形)渐变：<code>radial-gradient</code>: 主轴 次轴 at 原点x 原点y 初始色 结束色</li>
<li><code>background-image: radial-gradient</code>(圆心X 圆心Y at 渐变的X的起点 渐变的Y轴的起点, 渐变之的距离（可省略） 圆心中间的颜色, 扩散的颜色);<br>
<code>Background-image: radial-gradient(50px 50px at center center, hotpink 0%, skyblue 50%);</code></li>
</ul>
<h5 id="58css选择器优先级从大到小排序">58.CSS选择器优先级从大到小排序？</h5>
<p>!important(权重无穷大) &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 = 伪类选择器 &gt; 标签选择器 &gt;继承(子承父)或*(通配符)</p>
<h5 id="59怎么用css实现多行文字超出显示为省略号">59.怎么用css实现多行文字超出显示为省略号？</h5>
<p><code>overflow: hidden;</code><br>
将对象作为弹性伸缩盒子模型显示<br>
<code>display: -webkit-box;</code><br>
设置子元素排列方式<br>
<code>-webkit-box-orient: vertical;</code><br>
设置显示的行数，多出的部分会显示为...<br>
<code>-webkit-line-clamp: 3;</code></p>
<h5 id="60实现左边固定200px右边自适应的方法2种方式">60.实现左边固定200px,右边自适应的方法（2种方式）</h5>
<p>说明：这是其中的2种，你可以通过别的方式实现也算：<br>
方式一flex法：<br>
html代码</p>
<pre><code class="language-html">&lt; div class=&quot;left&quot; &gt;&lt;/div &gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码</p>
<pre><code class="language-css">html,
body {
display: flex;   
width: 100%;
height: 100%;
margin: 0;
padding: 0;
}
.left {
width: 200px;
height: 100%;
background-color: red;
}
.right {
flex: 1;
background-color: blue;
}
</code></pre>
<p>方式二浮动法：<br>
Html代码</p>
<pre><code class="language-html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码</p>
<pre><code class="language-css">html,
body {
width: 100%;
height: 100%;
margin: 0;
padding: 0;
position: relative;
}
.left {
float: left;
width: 200px;
height: 100%;
background-color: red;
}
.right {
height: 100%;
/* 挤开左边盒子 */
margin-left: 200px;
background-color: blue;
}
</code></pre>
<h5 id="62实现左边固定200px中间自适应右边固定200px的方法2种方式实现">62.实现左边固定200px,中间自适应，右边固定200px的方法(2种方式实现)？</h5>
<p>方式一浮动法：<br>
html代码：</p>
<pre><code class="language-html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码：</p>
<pre><code class="language-css">html,
body {
width: 100%;
height: 100px;
    
/* 重置样式 */
margin: 0;
padding: 0;
}

/* 左浮动 */
.left {
float: left;
width: 100px;
height: 100%;
background-color: red;
}

/* 中间自适应 */
.center {
height: 100%;
background-color: pink;
    
/* 挤开左右 */
margin-left: 100px;
margin-right: 100px;
}

/* 右浮动 */
.right {
float: right;
width: 100px;
height: 100%;
background-color: blue;
}
</code></pre>
<p>方式二定位法：<br>
html代码：</p>
<pre><code class="language-html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码：</p>
<pre><code class="language-css">html,
body {
position: relative;
width: 100%;
height: 100px;

/* 重置样式 */
margin: 0;
padding: 0;
}

/* 左定位 */
.left {
position: absolute;
top: 0;
left: 0;
width: 100px;
height: 100%;
background-color: red;
}

/* 中间自适应 */
.center {
height: 100%;
background-color: pink;

/* 挤开左右 */
margin-left: 100px;
margin-right: 100px;
}

/* 右定位 */
.right {
position: absolute;
top: 0;
right: 0;
width: 100px;
height: 100%;
background-color: blue;
}
</code></pre>
<p>方式三flex法：<br>
html代码：</p>
<pre><code class="language-html">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
</code></pre>
<p>css代码</p>
<pre><code class="language-css">html,
body {

/* 伸缩盒子 */
display: flex;
width: 100%;
height: 100px;

/* 重置样式 */
margin: 0;
padding: 0;
}

.left {
width: 100px;
height: 100%;
background-color: red;
}

.center {
/* 剩余空间占比 */
flex: 1;
background-color: pink;
}

.right {
width: 100px;
height: 100%;
background-color: blue;
}
</code></pre>
<h5 id="63说你对sass的理解和一些常用的语法有什么sass和less的有什么区别">63.说你对Sass的理解，和一些常用的语法有什么？Sass和Less的有什么区别？</h5>
<p>（找个题是开放性的，这个仅供参考，自己根据自己的理解去写，扩散思维）<br>
理解：Sass是一门css预处理语言，扩展css语言，添加了变量，函数等特性，让css更容易维护和扩展。</p>
<p>常用语法：①嵌套 ②&amp;  ③变量  ④混合器 ⑤继承、、</p>
<p>区别：1）在语法定义方面，比方说定义变量方面，Less通过@定义变量，Sass通过$定义变量，像混合器方面，			Less是通过.minxin的方式定义，Sass是通过@minxin的方式<br>
2）Sass支持条件语句，可以使用if{}else{},for{}循环等等，而Less不支持</p>
<h5 id="64css3的新属性有哪些举例说明5个中英文都写">64.css3的新属性有哪些？(举例说明5个，中英文都写)</h5>
<p>下面的必须牢记5个</p>
<pre><code class="language-css">1.圆角
border-radius	
2.阴影
1）文本阴影：text-shadow
2）盒子阴影：border-shadow
3.渐变
1）线性渐变：background-image: linear-gradient(方向,起始色,结束色);
2）圆形渐变：background-image: radial-gradient(主轴 次轴 at 圆点X 圆点Y, 起始色，结束色);
4.过渡
transition: ; 
5.2D转换
transform
6.转换原点
Transform-origin
7.3D变换
perspective
8.3D呈现
transform-style
9.动画
1）定义动画 @keyframes 动画名(identifier){ }
2）调用动画 animation
10.伸缩盒子（弹性盒子）
display: flex;
11.媒体查询
min-width、min-height、max-midth、max-height、、
</code></pre>
<h5 id="65-请列举6种表单元素">65. 请列举6种表单元素？</h5>
<pre><code class="language-css"> 表单元素有：
    ①	form（表单域）
    ②	input（表单控件）
    ③	button（按钮）
    ④	textarea（文本域）
    ⑤	select（下拉列表）
    ⑥	option（下拉列表选项）	
    下面的供参考：
    ⑦	fieldset（表单线框）
    ⑧	
    ⑨	legend（线框标题）
    ⑩	label（关联标签）

//  组合6个表单就可以，下面都是常用的,只要能写出6个就可以
&lt;input type=&quot;text&quot;&gt;        // 文本框
&lt;input type=&quot;radio&quot;&gt;       // 单选框
&lt;input type=&quot;checkbox&quot;&gt;    // 复选框
&lt;input type=&quot;password&quot;&gt;    //  密码框
&lt;form action=&quot;&quot;&gt;&lt;/form&gt;    // 表单
&lt;textarea  cols=&quot;&quot; rows=&quot;&quot;&gt;&lt;/textarea&gt;   // 文本框
&lt;select name=&quot;&quot; id=&quot;&quot;&gt;&lt;/select&gt;     // 下拉框
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Javacript基础编程题]]></title>
        <id>https://zjp693.github.io/post/javacript-ji-chu-bian-cheng-ti/</id>
        <link href="https://zjp693.github.io/post/javacript-ji-chu-bian-cheng-ti/">
        </link>
        <updated>2020-03-05T08:59:14.000Z</updated>
        <content type="html"><![CDATA[<p>目录</p>
<p>[toc]</p>
<h5 id="1定义2个数组let-arra-1233-let-arrb-2456求2个数组的并集交集">1.定义2个数组，let arrA = [1,2,3,3]; let arrB = [2,4,5,6]求2个数组的并集，交集</h5>
<pre><code class="language-js">let arrA = [1, 2, 3, 3];
let arrB = [2, 4, 5, 6];
let arrC = []
let arrD = arrA.concat(arrB)
console.log(arrD)

for (var i = 0; i &lt; arrA.length - 1; i++) {
    for (var u = 0; u &lt; arrB.length - 1; u++) {
        if (arrA[i] == arrB[u]) {
            arrC.push(arrA[i])
        }
    }
}
console.log(arrC)
</code></pre>
<h5 id="2随机产生一个十六进制的颜色值-例如90e353">2.随机产生一个十六进制的颜色值 ,例如：#90E353</h5>
<pre><code class="language-js">var str = &quot;#&quot;;
//一个十六进制的值的数组
var arr = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];
for (var i = 0; i &lt; 6; i++) {
  //产生的每个随机数都是一个索引,根据索引找到数组中对应的值,拼接到一起
  var num = parseInt(Math.random() * 16);
  str += arr[num];
}
console.log(str)
</code></pre>
<h5 id="3封装一个函数把一个时间日期对象转成yyyy-mm-dd-hhmmss">3.封装一个函数，把一个时间日期对象转成yyyy-mm-dd HH:mm:ss</h5>
<pre><code class="language-js">function time() {
    var c = new Date()
    var a = c.getSeconds()  //获取秒
    var minute = c.getMinutes()  //获取分钟
    var hour = c.getHours()    //获取小时
    var math = c.getMonth()    //返回月份   （从0开始）
    var year = c.getFullYear()  //返回年份
    var day = c.getDate()
    if (a &lt; 10) {
        a = &quot;0&quot; + a
    }
    if (minute &lt; 10) {
        minute = &quot;0&quot; + minute
    }
    if (hour &lt; 10) {
        hour = &quot;0&quot; + hour
    }
    if (math &lt; 10) {
        math = &quot;0&quot; + math
    }
    if (day &lt; 10) {
        day = &quot;0&quot; + day
    }
    console.log(year + &quot;-&quot; + math + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + a)
}
time()
</code></pre>
<h5 id="4获取指定数组中元素值为奇数的元素个数具体要求如下">4.获取指定数组中元素值为奇数的元素个数，具体要求如下：</h5>
<p>使用javascript定义函数getEvens实现要求：获取指定数组arr中元素值为奇数的元素个数，并返回</p>
<p>1).定义一个整数数组arr;<br>
2).获取4个1~50之间（包含1和50）的随机整数，并存入arr<br>
3).传递arr调用getEvens(arr)方法，获取返回值，并打印在控制台<br>
使用javascript定义函数getEvens实现要求：获取指定数组arr中元素值为奇数的元素个数，并返回</p>
<pre><code class="language-js"> 1).定义一个整数数组arr;
var arr = []

 2).获取4个1~50之间（包含1和50）的随机整数，并存入arr
for (var q = 0; q &lt; 4; q++) {
    arr.push(parseInt(Math.random() * 50 + 1))
}
 console.log(arr)

 3).传递arr调用getEvens(arr)方法，获取返回值，并打印在控制台
function getEvens(arr) {
    console.log(arr);
}
getEvens(arr)
</code></pre>
<h5 id="5定义一个函数-接收一个字符串数组-方法中打印姓-张的名字">5.定义一个函数， 接收一个字符串数组， 方法中打印姓 &quot;张&quot;的名字</h5>
<p>输入： [&quot;张三丰&quot;,&quot;李晓阳&quot;,&quot;大张&quot;,&quot;刘张伟&quot;,&quot;张章&quot;]</p>
<p>输出： 张三丰 张章</p>
<p>要求： 至少用3中方式判断姓是张</p>
<pre><code class="language-js">var arr = [&quot;张三丰&quot;, &quot;李晓阳&quot;, &quot;大张&quot;, &quot;刘张伟&quot;, &quot;张章&quot;];
for (var i = 0; i &lt; arr.length; i++) {
  if (arr[i][0] == &quot;张&quot;) {
  console.log(arr[i])
  }
}
</code></pre>
<h5 id="6找字符串里面的最长的单词和单词的长度">6.找字符串里面的最长的单词和单词的长度</h5>
<pre><code class="language-js">方式一：var s = &quot;yuan yuan yuan jiang jiang yong aaaaaaaaaaaaa aaaaaaaaaaaaa odpsospoaioaoaoaoaoao&quot;;
var arr = s.split(' ');
console.log(arr);
var str = &quot;yuan yuan yuan jiang jiang yong aaaaaaaaaaaaa aaaaaaaaaaaaa odpsospoaioaoaoaoaoao&quot;;
var arr = str.split(&quot; &quot;); // 转成字符串数组
// 假设数组的第一项是最大的
var maxStr = arr[0];
for (var i = 1; i &lt; arr.length; i++) {
  if (maxStr.length &lt; arr[i].length) {
    maxStr = arr[i]
  }
}
console.log(maxStr, maxStr.length); //odpsospoaioaoaoaoaoao 21

方式二：var str = &quot;yuan yuan yuan jiang jiang yong aaaaaaaaaaaaa aaaaaaaaaaaaa odpsospoaioaoaoaoaoao&quot;;
//分割字符串成数组
var arr = str.split(&quot; &quot;)
//假设第一个是最大的
var max = arr[0].length
//遍历数组
for (var i = 1; i &lt; arr.length; i++) {
  // 判断第一个是不是最大的
  if (max &lt; arr[i].length) {
    //把arr[i].length的值赋给max
    max = arr[i].length
    sum = arr[i]
  }
}
console.log(sum, max);
</code></pre>
<h5 id="7用指定整数替换指定数组中的元素值要求">7.用指定整数替换指定数组中的元素值，要求：</h5>
<p>使用javasctipt实现如下要求完成：<br>
1).定义一个数组arr，数组arr的值分别是1、2、3、4、5、6、7、8、9<br>
2).用户输出一个新的的整数num<br>
3).如果整数num为偶数，则用num替换数组arr中所有的偶数下标的元素值，<br>
如果整数num为奇数，则用num替换数组arr中所有的奇数下标的元素值<br>
4)	.在控制台上打印修改后的数组中的所有的元素值</p>
<pre><code class="language-js">方式一：var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];  // 0是特殊的偶数
var num = 1
for (var i = 0; i &lt; arr.length; i++) {
  if (num % 2 == 0 &amp;&amp; i % 2 == 0) {
    arr[i] = num;
  } else if (num % 2 !== 0 &amp;&amp; i % 2 !== 0) {
    arr[i] = num;
  }
}
console.log(arr)

方式二：var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];  // 0是特殊的偶数
var num = 1
for (var i = 0; i &lt; arr.length; i++) {
  if (num % 2 == 0 &amp;&amp; i % 2 == 0) {
    arr[i] = num
  }
  if (num % 2 != 2 &amp;&amp; i % 2 != 0) {
    arr[i] = num
  }
}
console.log(arr);
</code></pre>
<h5 id="8编写函数function-getnumtimes函数中完成下面功能">8.编写函数function getNumTimes(),函数中完成下面功能：</h5>
<p>1)函数中定义长度是5的数组，数组元素为1-99(包含1和99)之间的随机数，打印出该数组的元素。<br>
2)提示用户输入2-5之间的数字num,<br>
3)遍历数组arr,<br>
4)筛选出数组中元素是num整数倍的所有数组元素，存放进一个新的数组中，该新的数组作为该方法返回值返回</p>
<h5 id="9用户定义一个数字数字的范围在-1-9999之间">9.用户定义一个数字，数字的范围在 1-9999之间，</h5>
<p>如果输入的数字是 1位数，则数字前面补全 3个0，使之成为”000x”<br>
如果输入的数字是2位数，则数字前面补全2个0,  使之成为”00xx”<br>
如果输入的数字是3位数，则数字前面补全1个0，使之成为”0xxx”<br>
如果输入的数字是4位数，则不用补全。<br>
最后将结果打印出来。</p>
<pre><code>
</code></pre>
<h5 id="10将字符串中所有的小写字母转成大写字母统计替换了多少个小写字母并将原来的大写字母转成小写字母统计替换了多少个大写字母">10.将字符串中所有的小写字母转成大写字母,统计替换了多少个小写字母，并将原来的大写字母转成小写字母，统计替换了多少个大写字母。</h5>
<p>示例：“abCDefG”转换后的结果是“ABcdEFg”</p>
<h5 id="11定义2个数组let-arra-1233-let-arrb-2456求2个数组的并集交集">11.定义2个数组，let arrA = [1,2,3,3]; let arrB = [2,4,5,6]求2个数组的并集，交集</h5>
<pre><code class="language-js">//并集
let arrA = [1, 2, 3, 3];
let arrB = [2, 4, 5, 6];
let arrC = []
let arrD = arrA.concat(arrB)
console.log(arrD)

//交集
for (var i = 0; i &lt; arrA.length - 1; i++) {
  for (var u = 0; u &lt; arrB.length - 1; u++) {
   if (arrA[i] == arrB[u]) {
    arrC.push(arrA[i])
    }
  }
}

console.log(arrC)
</code></pre>
<h5 id="定义方法-判定直角三角形-isrighttriangle参数为三角形的三条边返回值为布尔值是直角三角形为true否则false">定义方法 判定直角三角形, isRightTriangle,参数为三角形的三条边，返回值为布尔值，是直角三角形为true，否则false</h5>
<p>直接三角形判断方法：最大边的长度平方 = 剩余两条边的平方和<br>
示例：<br>
输入: isRightTriangle(5,3,4)<br>
返回：true<br>
解释：最大边长度5,5<em>5 = 3</em>3+4*4</p>
<p>示例：<br>
输入: isRightTriangle(3,6,4)<br>
返回：false<br>
解释：最大边长度6, 6<em>6=36 不等于 3</em>3+4*4</p>
<p>方法一</p>
<pre><code class="language-js">function isRightTriangle(a, b, c) {
  var m = Math.max(a, b, c);
  if (m == a &amp;&amp; a * a == (c * c + b * b)) {
    return true;
  }
  if (m == b &amp;&amp; b * b == (c * c + a * a)) {
    return true;
  }
  if (m == c &amp;&amp; c * c == (a * a + b * b)) {
    return true;
  }
  return false;
}
console.log(isRightTriangle(3, 6, 4))
</code></pre>
<pre><code class="language-js">Math.pow(a,2) // 这个Math.pow是求某个数的几次方

b*b = a*c +c*c  可以写成 Math.pow(a,2) = Math.pow(b,2)+Math.pow(c,2)
</code></pre>
<p>方法二</p>
<pre><code class="language-js">function isRightTriangle(a, b, c) {
  if (a &gt; b &amp;&amp; a &gt; c &amp;&amp; a * a == (c * c + b * b)) {
    return true
  } else if (b &gt; a &amp;&amp; b &gt; c &amp;&amp; b * b == (c * c + a * a)) {
    return true
  } else if (c &gt; a &amp;&amp; c &gt; b &amp;&amp; c * c == (a * a + b * b)) {
    return true
  } else {
    return false;
  }
}
console.log(isRightTriangle(3, 6, 5))
</code></pre>
<h5 id="12使用javascript-编写代码在控制台中输出字符串assdfscfwssseeeztmsa中出现次数最多的字符并统计出现的次数10分">12.使用javascript 编写代码，在控制台中输出字符串”assdfscfwssseeeztmsa”中出现次数最多的字符，并统计出现的次数（10分）</h5>
<pre><code class="language-js">var str = &quot;assdfscfwssseeeztmsa&quot;
var obj = {}
for (var i = 0; i &lt; str.length; i++) {
  if (obj[str[i]]) {
    obj[str[i]]++;
  } else {
    obj[str[i]] = 1;
  }
}
console.log(obj);

var maxTimes = 0
var alpha = &quot;&quot;
for (var key in obj) {
  if (maxTimes &lt; obj[key]) {
    maxTimes = obj[key]
    alpha = key
  }
}
console.log(`出现次数最多的字母是${alpha},出现的次数是${maxTimes}`)
</code></pre>
<h5 id="13使用js实现下列问题">13.使用js实现下列问题</h5>
<p>1)用户输入一个变量num，<br>
2)如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz<br>
3)如果 num 能被 3 整除，返回字符串 fizz<br>
4)如果 num 能被 5 整除，返回字符串 buzz<br>
5)如果参数为空或者不是 Number 类型，返回 false<br>
6)其余情况，返回参数 num</p>
<pre><code class="language-js">function fizzBuzz(num){
  if(num &amp;&amp; typeof num == 'number'){
   if(num % 3 == 0 &amp;&amp; num % 5 == 0){
    return 'fizzbuzz'
       
    }else if(num % 3 == 0){
     return 'fizz'
        
   }else if(num % 5 == 0){
	return 'buzz'
       
    } else{
      return num;
    }
      
   }else{
    return false;
       
  }
}
console.log(fizzBuzz(15));
</code></pre>
<h5 id="14用变量n接收用户输入的数字当n为奇数时-返回-1-1-3-1-5-1-n-的和-当n为偶数时-返回-1-1-2-1-4-1-6-1-n-的和">14.用变量n接收用户输入的数字，当n为奇数时, 返回 1 + 1 / 3 + 1 / 5 +.....+ 1 / n 的和, 当n为偶数时, 返回 1 + 1 / 2 + 1 / 4 + 1 / 6 + .....+ 1 / n 的和;</h5>
<pre><code class="language-js">var n
if (n % 2 == 0) { 
  for (var i = 2, even = 0; i &lt;= n; i += 2) { 
    even += 1 / i;
  }
  console.log(even);

} else {
  for (var j = 1, odd = 0; j &lt;= n; j += 2) {
    odd += 1 / j;
  }
  console.log(odd);
}

for (var i = 1; i &lt;= 1000; i++) {
  if (i % 2 == 0 &amp;&amp; i % 10 != 0) {
    if (i % 6 == 0) {
      console.log(i);
    }
  }
}
</code></pre>
<h5 id="15-定义数组var-arr-12345612312将数组重复的元素去重请使用2种方式实现">15. 定义数组var arr = [1,2,3,4,5,6,1,2,3,1,2],将数组重复的元素去重,(请使用2种方式实现)</h5>
<pre><code class="language-js">var arr = [1, 2, 3, 4, 5, 6, 1, 2, 3, 1, 2]
 var newArr = [];
  for (var i = 0; i &lt; arr.length; i++) {
    if (newArr.indexOf(arr[i]) == -1) {
    newArr.push(arr[i]);
   }
  }
  console.log(newArr);

function unique3(array) {
   var n = [array[0]]; //结果数组
   //从第二项开始遍历
   for (var i = 1; i &lt; array.length; i++) {

    //如果当前数组的第i项在当前数组中第一次出现的位置不是i，
    //那么表示第i项是重复的，忽略掉。否则存入结果数组

    if (array.indexOf(array[i]) == i) n.push(array[i]);
   }
   return n;
  }
</code></pre>
<h5 id="16写一个函数该函数用于计算一个正数的因子和比如6的因子和是123612">16.写一个函数，该函数用于计算一个正数的因子和（比如6的因子和是1+2+3+6=12）</h5>
<pre><code class="language-js">function get(num) {
    var sum = 0;
    for (i = 1; i &lt;= num; i++) {
        if (num % i == 0) {
            sum += i;
        };
    };
    return sum;
}
var result = get(6);
console.log(result);
</code></pre>
<h5 id="17编写一个函数计算任意两个数字之间所能组成的奇数个数数字必须是个位数-组成的奇数不能超过2位数数字可以循环使用">17.编写一个函数，计算任意两个数字之间所能组成的奇数个数，数字必须是个位数。（组成的奇数不能超过2位数，数字可以循环使用）</h5>
<p>比如： 计算0-3之间能组成的奇数个是01、03、11、13、21、23、31、33</p>
<pre><code class="language-js">function getOdd(m, n) {
    if (m &gt;= 10 || n &gt;= 10) {//如果m,n大于10 ，直接返回
        return;
    }
    if (m &gt; n) {//如果m大于n,调换m,n的位置
        var temp = m;
        m = n;
        n = temp;
    }
    //for循环生成i,j之间的所有值
    for (var i = m; i &lt;= n; i++) {
        for (var j = m; j &lt;= n; j++) {
            if (i != j &amp;&amp; j % 2 != 0) {//i!=j并且j不为偶数满足条件输出
                console.log(&quot;&quot; + i + j);//打印i,j的字符串输出
            }
        }
    }
}
getOdd(0, 3);
</code></pre>
<h5 id="18获取指定数组中元素值为偶数并且小于指定整数的元素个数要求如下">18.获取指定数组中元素值为偶数并且小于指定整数的元素个数，要求如下：</h5>
<p>使用javascript定义函数完成要求：获取指定数组arr中元素值小于指定整数num并且元素值为偶数的元素个数，返回获取到的元素个数</p>
<p>1)定义数组arr</p>
<p>2)用户输入5个整数，并存入数组arr中，输入前提示当前输入的是第几个整数</p>
<p>3)用户在输入1个整数num</p>
<p>4)传递数组arr和num调用getInfo(arr,num)方法，获取返回值，并在控制台打印输出</p>
<pre><code class="language-js">var num = prompt('请输入需要小于的一个指定整数');
function getInfo(arr, num) {
    var result = ''
    for (var i = 0; i &lt; arr.length; i++) {
        if (arr[i] % 2 == 0 &amp;&amp; arr[i] &lt; num) {
            result += arr[i] + ' ';
        }
    }
    return result;
}
var result = getInfo(arr, num);
alert(`${arr}中为偶数且小于${num}的元素是${result}`);
</code></pre>
<h5 id="19获取数组中元素值为偶数的累加和与元素值为奇数的累加和并计算出它们之间的差值要求">19.获取数组中元素值为偶数的累加和与元素值为奇数的累加和，并计算出它们之间的差值，要求：</h5>
<p>使用javascript定义函数 getNum(arr)，完成如下要求：<br>
1）用户输入5个整数，并存放在数组arr中 ，输入前提示输入的是第几个值<br>
2）获取指定数组arr中元素值为偶数的累加和<br>
3）获取指定数组arr中元素值为奇数的累加和<br>
4）返回偶数累加和与奇数累加和之间的差值<br>
5）传递数组arr调用getNum(arr)函数,获取返回值，并打印输出</p>
<pre><code class="language-js">   var arr = []
        var jsum = 0, osum = 0
        for (var i = 1; i &lt;= 5; i++) {
            var number = +prompt(&quot;请输入第&quot; + i + &quot;位整数&quot;)
            arr.push(number)
        }
        for (var j = 0; j &lt; arr.length; j++) {
            if (arr[j] % 2 == 0) {
                jsum += arr[j]
            }
            if (arr[j] % 2 != 0) {
                osum += arr[j]
            }
             }
    function getNum(arr) {
        console.log(osum - jsum);
    }
    getNum(arr)
</code></pre>
<h5 id="20求出1-1213-14-1100的和">20.求出1-1/2+1/3-1/4…..-1/100的和</h5>
<pre><code class="language-js">var i = 1; //分子始终为1,设i为分母
var sum = 0;
for (i = 1; i &lt;= 100; i++) {
    if (i % 2 == 0) {  //判断分母i是否为偶数，如果为偶数就乘以-1，使分母变为负数，此时运算符号变成-
        sum += 1 / (-1 * i);
    } else {  //如果i不为偶数，便正常进行加法运算
        sum += 1 / i;
    }
}
console.log(sum);
console.log(sum);
</code></pre>
<h5 id="21有一组带前缀的-整数-字母加数字-a5-b6-ab7-yr99-整数的位数都不确定-要求设计一个函数把这样的-整数-加上1">21.有一组带前缀的“ 整数”（ 字母加数字）：“ A5”, ”B6”, ”AB7”, ”YR99”， 整数的位数都不确定， 要求设计一个函数把这样的“ 整数” 加上1</h5>
<p>例如：<br>
“ A5” 经过方法运算后返回结果是“ A6”，<br>
“ AE7” 经过方法运算后返回结果是“ AE8”，<br>
“ YR99” 经过方法运算后返回结果是“ YR100”<br>
定义一个函数， 接收一个字符串： 字符串左边是英文字母， 右边是数字， 返回 + 1 后的结果</p>
<pre><code class="language-js">var str = 'hafff55hhhh'
for (var i = 0; i &lt; str.length; i++) {
    if (str[i] &gt;= 0 &amp;&amp; str[i] &lt;= 9) {
        break
    }
}
sum = +str.substr(i) + 1
num = str.slice(0, i)
console.log(num + sum);
</code></pre>
<h5 id="22查询学生相关信息使用javascript实现如下要求">22.查询学生相关信息，使用javascript实现如下要求：</h5>
<p>有一个二维数组，每条数据固定stuid表示学号,name表示姓名,gender表示性别<br>
var students = [<br>
{ stuid: &quot;S01&quot;, name: &quot;周夏&quot;, gender: &quot;男&quot;,score: 86 },<br>
{ stuid: &quot;S02&quot;, name: &quot;郑竹&quot;, gender: &quot;男&quot;,score: 77 },<br>
{ stuid: &quot;S03&quot;, name: &quot;吴兰&quot;, gender: &quot;女&quot;,score: 35},<br>
{ stuid: &quot;S04&quot;, name: &quot;李云&quot;, gender: &quot;男&quot;,score: 56 }<br>
];<br>
解释：{stuid:&quot;S01&quot;,name:&quot;周夏&quot;,gender:&quot;男&quot;}表示学生&quot;周夏&quot;的学号是&quot;S01&quot;，性别是&quot;男&quot;;</p>
<p>1.定义函数totalBySex，<br>
要求：接收学生信息二维数组students，函数中查询男生、女生各多少人并将结果返回<br>
示例：<br>
男生人数：3人<br>
女生人数：1人<br>
2.定义函数getMaxScore,<br>
要求:接收学生信息二维数组students,函数中找出成绩最高的学生姓名，并将结果返回</p>
<pre><code class="language-js">var students = [
    { stuid: &quot;S01&quot;, name: &quot;周夏&quot;, gender: &quot;男&quot;, score: 86 },
    { stuid: &quot;S02&quot;, name: &quot;郑竹&quot;, gender: &quot;男&quot;, score: 77 },
    { stuid: &quot;S03&quot;, name: &quot;吴兰&quot;, gender: &quot;女&quot;, score: 35 },
    { stuid: &quot;S04&quot;, name: &quot;李云&quot;, gender: &quot;男&quot;, score: 56 }
];
var j = 0, k = 0, sum = students[0]
for (var i = 0; i &lt; students.length; i++) {
    if (students[i].gender == &quot;男&quot;) {
        j++
    }
    if (students[i].gender == &quot;女&quot;) {
        k++
    }
    if (sum.score &lt; students[i].score) {
        sum = students[i].score
    }
}
function getMaxScore(students) {
    console.log(`男生人数${j}人，女生人数${k}人，最高成绩的同学是${sum}分`)
}
</code></pre>
<h5 id="23判分小程序-学生答案var-str-aabcda-正确答案var-ans-aaccbdb-表示一共5题-答对一题3分">23.判分小程序： 学生答案var str = &quot;a#ab#c#D#a&quot;, 正确答案var  ans = &quot;A#AC#C#BD#B&quot;, 表示一共5题， 答对一题3分</h5>
<p>定义函数， 接收学生答案和正确答案， 计算学生得分并返回分数</p>
<pre><code class="language-js">var ans = &quot;A#AC#C#BD#B&quot;
var str = &quot;a#ab#c#D#a&quot;
var str = str.toUpperCase()
var newans = ans.split(&quot;#&quot;)
var newstr = str.split(&quot;#&quot;)
var j = 0
for (var i = 0; i &lt; newans.length; i++) {
    if (newans[i] == newstr[i])
        j++
}
console.log(`${j * 3}分`);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jsvascript基础简答题]]></title>
        <id>https://zjp693.github.io/post/javascript-ji-chu-jian-da-ti/</id>
        <link href="https://zjp693.github.io/post/javascript-ji-chu-jian-da-ti/">
        </link>
        <updated>2020-03-05T04:01:47.000Z</updated>
        <summary type="html"><![CDATA[<p>文章收集于学校上课练习，互联网</p>
]]></summary>
        <content type="html"><![CDATA[<p>文章收集于学校上课练习，互联网</p>
<!-- more -->
<ol>
<li>
<h5 id="js数据类型有哪些怎么判断一个变量的数据类型">js数据类型有哪些，怎么判断一个变量的数据类型？</h5>
</li>
</ol>
<pre><code class="language-js">jS数据类型有：Number数字、String字符串、Boolean布尔、Null空、Undefined未定义、Object对象
使用 typeof 变量 可以判断该变量的数据类型，但是typeof只能判断的是简单数据类型，不能判断复杂数据类型。
</code></pre>
<ol start="2">
<li>
<h5 id="列举数组中常用的方法并说明各自的作用">列举数组中常用的方法，并说明各自的作用？</h5>
</li>
</ol>
<pre><code class="language-js">unshift();向数组的开头添加一个或更多元素，并返回新的长度。			 会改变数组的长度
push(); 向数组的末尾添加一个或多个元素，并返回新的长度。			 会改变数组的长度

shift();把数组的第一个元素从其中删除，并返回第一个元素的值。		    会改变数组的长度
pop(); 用于删除数组的最后一个元素并返回删除的元素。				   会改变数组的长度

indexOf(); 查看某个元素在数组中的下标位置，有返回下标，无返回-1
splice(开始元素，删除个数，添加元素); 增删改作用集一身  			   会改变原始数组。

slice(); 截取元素，返回的是截取之后元素组成的数组					不会改变原始数组
concat(); 合并数组，返回值是合并之后的新数组
</code></pre>
<ol start="3">
<li>
<h5 id="javascript中的循环有哪些while循环和dowhile的区别是什么">javascript中的循环有哪些，while循环和do...while的区别是什么？</h5>
</li>
</ol>
<pre><code class="language-js">for循环、while循环、do...while循环

区别：while先判断条件再执行，do..while先执行一次再判断条件是否继续执行
</code></pre>
<ol start="4">
<li>
<h5 id="javascript中的有几层含义分别是什么">javascript中的‘+’有几层含义，分别是什么？</h5>
</li>
</ol>
<pre><code class="language-js">第一层意义，当 + 号的两边都是number类型的时候，此时 + 号 代表数学符号加法

第二层意义，当 + 号的两边，只要有一边是string类型的时候，此时 + 号代表字符串的连接符

第三层意义，+可以进行数据类型的隐式转换，给一个string类型的数据前面加上+号，就会把这个字符串变成数字
</code></pre>
<ol start="5">
<li>
<h5 id="js中break-和-continue-的区别是什么">js中break 和 continue 的区别是什么？</h5>
</li>
</ol>
<pre><code class="language-js">break：跳出整个循环执行下面的代码
 continue：跳出本轮循环执行下一轮循环
</code></pre>
<ol start="6">
<li>
<h5 id="列举目前你遇到undefined的情况">列举目前你遇到undefined的情况？</h5>
</li>
</ol>
<pre><code class="language-js">1）变量只声明没有赋值，会返回undefined；

2）当下标超过数组或字符串的范围 ，会返回undefined；

3）当对象调用不存在的属性时，会返回undefined；

4）当return没有返回值，会返回undefined；
</code></pre>
<ol start="7">
<li>
<h5 id="产生一个10-50的随机数包含10也包含50">产生一个10-50的随机数(包含10也包含50)?</h5>
</li>
</ol>
<pre><code class="language-js">Math.random() * (50 - 10 + 1) + 10

【注意通用公式是: 产生一个[n,m]的整数，包含（n和m）

Math.ceil (Math.random()*(m-n)+n)】
</code></pre>
<ol start="8">
<li>
<h5 id="列举5个字符串的方法并说明各自的作用">列举5个字符串的方法，并说明各自的作用？</h5>
</li>
</ol>
<pre><code class="language-js">charAt(索引); 返回对象字符

concat(); 拼接字符串

indexOf(); 查找某串字符在字符串内的索引，有返回索引无返回-1

trim(); 去掉字符串前后的空格

slice() 从start位置 截取到end位置

split() 选择字符分割成数组储存
</code></pre>
<ol start="9">
<li>
<h5 id="join和split的区别是什么">join()和split()的区别是什么？</h5>
</li>
</ol>
<pre><code class="language-js">join()；是数组方法，把数组中的元素转成字符串连接

split(); 是字符串的方法，方法用于把一个字符串分割成字符串数组
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea+Github快速教程]]></title>
        <id>https://zjp693.github.io/post/grideagithub-kuai-su-jiao-cheng/</id>
        <link href="https://zjp693.github.io/post/grideagithub-kuai-su-jiao-cheng/">
        </link>
        <updated>2020-01-05T11:11:36.000Z</updated>
        <content type="html"><![CDATA[<h5 id="想知道如何使用gridea吗">想知道如何使用Gridea吗？</h5>
<p>Git</p>
<p>Git https://git-scm.com</p>
<h5 id="下载后安装">下载后安装</h5>
<p>安装完之后在桌面右键Git Bash Here，输入以下内容进行配置</p>
<p>$ git config --global user.name &quot;sailorlisa&quot;</p>
<p>$ git config --global user.email &quot;sailorlisa@outlook.com&quot;</p>
<h5 id="github">Github</h5>
<p>Github账号 https://github.com</p>
<p>每个github账号有1个免费的github pages</p>
<p>如果免费的已被占用（例如hexo），得自行注册新的github账号或者自行买域名，在仓库里的github pages里设置好</p>
<h5 id="仓库">仓库</h5>
<p>点击create a new repositories</p>
<p>输入Repository name：Cyberlisa.github.io。固定格式：.github.io</p>
<p>Description可填可不填。</p>
<h5 id="勾选public">勾选Public</h5>
<p>勾选Intialize this repository with a README(可不勾选)</p>
<p>点击Create repository</p>
<p>自动跳转到仓库页面，点击Insights后面的Settings</p>
<p>拉到下面GitHub Pages，看看有没有显示：Your site is published at https://cyberlisa.github.io/</p>
<p>没有的话稍微等一下再试</p>
<p>有的话点击链接跳转，看看能否打开</p>
<h5 id="token">Token</h5>
<p>在github界面点击头像，点击Settings——&gt;Personal settings——&gt;Developer settings</p>
<h5 id="找到最后的personal-access-tokensgenerate-new-token填写note勾选repogenerate-token">找到最后的Personal access tokens——&gt;Generate new token——&gt;填写Note——&gt;勾选repo——&gt;Generate token</h5>
<p>创建个txt文档，把token保存起来。如果不保存，那先不要关闭这个页面，待会儿需要用到token。</p>
<p>Gridea配置</p>
<h5 id="下载安装">下载安装</h5>
<p>在https://gridea.dev下载符合自己系统的客户端，安装。</p>
<p>安装完之后打开，如果在【文章】里看到一片空白，卸载整个客户端，重新安装。</p>
<h5 id="填配置">填配置</h5>
<p>如果打开后能看到默认的2篇文章，点击【配置】：</p>
<h5 id="platform-github-pages">Platform  Github Pages</h5>
<p>域名 Github Pages 对应的域名 https://cyberlisa.github.io/</p>
<p>仓库 github上仓库名 Cyberlisa.github.io</p>
<p>分支 Github Pages 对应的分支 master</p>
<p>仓库用户名  仓库所属用户的用户名 Cyberlisa</p>
<p>邮箱 Git 推送时的邮箱 sailorlisa@163.com</p>
<p>Token    上面步骤里的token</p>
<h5 id="cname-可不填">CNAME    可不填</h5>
<p>填完配置后，点击【保存】</p>
<p>无误后，点击【检测远程连接】</p>
<p>点击【预览】，会弹出浏览器，本地预览效果。</p>
<p>可在【主题】里选择其他内置主题，不要忘记拉到下面选择【保存】</p>
<p>选择了其他主题后，点击【预览】</p>
<p>如果没问题，点击【同步】</p>
<p>稍等3分钟左右，点击同步按钮下面那个像地球的网格图标，会在浏览器自动弹出博客网页。看看有没有什么问题。</p>
<p>在客户端里进行任何操作，不要忘记点击【保存】。保存了之后先预览，没问题再同步。</p>
<p>有问题点击https://github.com/getgridea/gridea里的【Issues】，在【Open】和【Closed】里看看有没有和你问题相似的issue。</p>
<h5 id="defender">Defender</h5>
<p>如果你是win10用户，在操作时出现异常，看看通知里有没有defender的警告。我一开始根本操作不了客户端，因为defender限制权限。把defender关了之后才能正常使用。</p>
<h5 id="更换walker主题">更换Walker主题</h5>
<p>在https://gridea.dev/themes/购买Walker主题，购买完后点击【下载文件】，下载后解压。</p>
<p>点击客户端里的【系统】，找到【源文件夹】，自己打开路径。退出Gridea客户端。</p>
<p>点击【themes】，把walker文件夹复制过来，打开Gridea客户端，打开【主题】，选择主题，滚动下鼠标，选中最后的Walker，保存。</p>
]]></content>
    </entry>
</feed>